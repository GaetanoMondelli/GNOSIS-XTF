{
  "address": "0x7B25401E9ce0714FF493d0cc679806B309F9cD19",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "sourceChainId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "commitmentsSlot",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "giriGiriBashi",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "accountRlp",
          "type": "bytes"
        }
      ],
      "name": "InvalidAccountRlp",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidAccountStorageRoot",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "blockHeaderHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "expectedBlockHeaderHash",
          "type": "bytes32"
        }
      ],
      "name": "InvalidBlockHeader",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "latestCommitment",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "expectedLatestCommitment",
          "type": "bytes32"
        }
      ],
      "name": "InvalidLatestCommitment",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expectedNonce",
          "type": "uint256"
        }
      ],
      "name": "InvalidNonce",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ACCOUNT",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "COMMITMENTS_SLOT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "GIRI_GIRI_BASHI",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SOURCE_CHAIN_ID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "blockNumber",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "storageRoot",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "storageProof",
              "type": "bytes"
            }
          ],
          "internalType": "struct IProver.Proof",
          "name": "proof",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "_verifyProof",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "expectedNonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "setAccount",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x0b25eecb450d71a761ee1767652192f8082e5b324e9c530c8862fabe2fad6940",
  "receipt": {
    "to": null,
    "from": "0x2a1F5eB3e84e58e6F1e565306298B9dE1273f203",
    "contractAddress": "0x7B25401E9ce0714FF493d0cc679806B309F9cD19",
    "transactionIndex": 88,
    "gasUsed": "686226",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x98f3186b0bb0f4edc18d4dbb410613bae8a601ff064b07a6ea70d68ea6a4a918",
    "transactionHash": "0x0b25eecb450d71a761ee1767652192f8082e5b324e9c530c8862fabe2fad6940",
    "logs": [],
    "blockNumber": 5731615,
    "cumulativeGasUsed": "17847766",
    "status": 1,
    "byzantium": true
  },
  "args": [
    11155111,
    "0x0",
    "0x2a1F5eB3e84e58e6F1e565306298B9dE1273f203"
  ],
  "numDeployments": 14,
  "solcInputHash": "8cea3200be17ea18e264fc9ffed968c1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sourceChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitmentsSlot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"giriGiriBashi\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"accountRlp\",\"type\":\"bytes\"}],\"name\":\"InvalidAccountRlp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAccountStorageRoot\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"blockHeaderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expectedBlockHeaderHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidBlockHeader\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"latestCommitment\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expectedLatestCommitment\",\"type\":\"bytes32\"}],\"name\":\"InvalidLatestCommitment\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedNonce\",\"type\":\"uint256\"}],\"name\":\"InvalidNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ACCOUNT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COMMITMENTS_SLOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GIRI_GIRI_BASHI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SOURCE_CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"storageRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"storageProof\",\"type\":\"bytes\"}],\"internalType\":\"struct IProver.Proof\",\"name\":\"proof\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"_verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expectedNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Prover.sol\":\"Prover\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa94b34880e3c1b0b931662cb1c09e5dfa6662f31cba80e07c5ee71cd135c9673\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/MerklePatriciaProofVerifier.sol\":{\"content\":\"pragma solidity ^0.8.20;\\n/* solhint-disable */\\n\\nimport { RLPReader } from \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\n\\nlibrary MerklePatriciaProofVerifier {\\n\\tusing RLPReader for RLPReader.RLPItem;\\n\\tusing RLPReader for bytes;\\n\\n\\t/// @dev Validates a Merkle-Patricia-Trie proof.\\n\\t///      If the proof proves the inclusion of some key-value pair in the\\n\\t///      trie, the value is returned. Otherwise, i.e. if the proof proves\\n\\t///      the exclusion of a key from the trie, an empty byte array is\\n\\t///      returned.\\n\\t/// @param rootHash is the Keccak-256 hash of the root node of the MPT.\\n\\t/// @param path is the key of the node whose inclusion/exclusion we are\\n\\t///        proving.\\n\\t/// @param stack is the stack of MPT nodes (starting with the root) that\\n\\t///        need to be traversed during verification.\\n\\t/// @return value whose inclusion is proved or an empty byte array for\\n\\t///         a proof of exclusion\\n\\tfunction extractProofValue(\\n\\t\\tbytes32 rootHash,\\n\\t\\tbytes memory path,\\n\\t\\tRLPReader.RLPItem[] memory stack\\n\\t) internal pure returns (bytes memory value) {\\n\\t\\tbytes memory mptKey = _decodeNibbles(path, 0);\\n\\t\\tuint256 mptKeyOffset = 0;\\n\\n\\t\\tbytes32 nodeHashHash;\\n\\t\\tRLPReader.RLPItem[] memory node;\\n\\n\\t\\tRLPReader.RLPItem memory rlpValue;\\n\\n\\t\\tif (stack.length == 0) {\\n\\t\\t\\t// Root hash of empty Merkle-Patricia-Trie\\n\\t\\t\\trequire(\\n\\t\\t\\t\\trootHash ==\\n\\t\\t\\t\\t\\t0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\n\\t\\t\\t);\\n\\t\\t\\treturn new bytes(0);\\n\\t\\t}\\n\\n\\t\\t// Traverse stack of nodes starting at root.\\n\\t\\tfor (uint256 i = 0; i < stack.length; i++) {\\n\\t\\t\\t// We use the fact that an rlp encoded list consists of some\\n\\t\\t\\t// encoding of its length plus the concatenation of its\\n\\t\\t\\t// *rlp-encoded* items.\\n\\n\\t\\t\\t// The root node is hashed with Keccak-256 ...\\n\\t\\t\\tif (i == 0 && rootHash != stack[0].rlpBytesKeccak256()) {\\n\\t\\t\\t\\trevert(\\\"Root hash does not match the first proof element\\\");\\n\\t\\t\\t}\\n\\t\\t\\t// ... whereas all other nodes are hashed with the MPT\\n\\t\\t\\t// hash function.\\n\\t\\t\\tif (i != 0 && nodeHashHash != _mptHashHash(stack[0])) {\\n\\t\\t\\t\\trevert();\\n\\t\\t\\t}\\n\\t\\t\\t// We verified that stack[i] has the correct hash, so we\\n\\t\\t\\t// may safely decode it.\\n\\t\\t\\t// node = stack[i].toList();\\n\\n\\t\\t\\t// if (node.length == 2) {\\n\\t\\t\\t//     // Extension or Leaf node\\n\\n\\t\\t\\t//     bool isLeaf;\\n\\t\\t\\t//     bytes memory nodeKey;\\n\\t\\t\\t//     (isLeaf, nodeKey) = _merklePatriciaCompactDecode(node[0].toBytes());\\n\\n\\t\\t\\t//     uint256 prefixLength = _sharedPrefixLength(mptKeyOffset, mptKey, nodeKey);\\n\\t\\t\\t//     mptKeyOffset += prefixLength;\\n\\n\\t\\t\\t//     if (prefixLength < nodeKey.length) {\\n\\t\\t\\t//         // Proof claims divergent extension or leaf. (Only\\n\\t\\t\\t//         // relevant for proofs of exclusion.)\\n\\t\\t\\t//         // An Extension/Leaf node is divergent iff it 'skips' over\\n\\t\\t\\t//         // the point at which a Branch node should have been had the\\n\\t\\t\\t//         // excluded key been included in the trie.\\n\\t\\t\\t//         // Example: Imagine a proof of exclusion for path [1, 4],\\n\\t\\t\\t//         // where the current node is a Leaf node with\\n\\t\\t\\t//         // path [1, 3, 3, 7]. For [1, 4] to be included, there\\n\\t\\t\\t//         // should have been a Branch node at [1] with a child\\n\\t\\t\\t//         // at 3 and a child at 4.\\n\\n\\t\\t\\t//         // Sanity check\\n\\t\\t\\t//         if (i < stack.length - 1) {\\n\\t\\t\\t//             // divergent node must come last in proof\\n\\t\\t\\t//             revert();\\n\\t\\t\\t//         }\\n\\n\\t\\t\\t//         return new bytes(0);\\n\\t\\t\\t//     }\\n\\n\\t\\t\\t//     if (isLeaf) {\\n\\t\\t\\t//         // Sanity check\\n\\t\\t\\t//         if (i < stack.length - 1) {\\n\\t\\t\\t//             // leaf node must come last in proof\\n\\t\\t\\t//             revert();\\n\\t\\t\\t//         }\\n\\n\\t\\t\\t//         if (mptKeyOffset < mptKey.length) {\\n\\t\\t\\t//             return new bytes(0);\\n\\t\\t\\t//         }\\n\\n\\t\\t\\t//         rlpValue = node[1];\\n\\t\\t\\t//         return rlpValue.toBytes();\\n\\t\\t\\t//     } else {\\n\\t\\t\\t//         // extension\\n\\t\\t\\t//         // Sanity check\\n\\t\\t\\t//         if (i == stack.length - 1) {\\n\\t\\t\\t//             // shouldn't be at last level\\n\\t\\t\\t//             revert();\\n\\t\\t\\t//         }\\n\\n\\t\\t\\t//         if (!node[1].isList()) {\\n\\t\\t\\t//             // rlp(child) was at least 32 bytes. node[1] contains\\n\\t\\t\\t//             // Keccak256(rlp(child)).\\n\\t\\t\\t//             nodeHashHash = node[1].payloadKeccak256();\\n\\t\\t\\t//         } else {\\n\\t\\t\\t//             // rlp(child) was less than 32 bytes. node[1] contains\\n\\t\\t\\t//             // rlp(child).\\n\\t\\t\\t//             nodeHashHash = node[1].rlpBytesKeccak256();\\n\\t\\t\\t//         }\\n\\t\\t\\t//     }\\n\\t\\t\\t// } else if (node.length == 17) {\\n\\t\\t\\t//     // Branch node\\n\\n\\t\\t\\t//     if (mptKeyOffset != mptKey.length) {\\n\\t\\t\\t//         // we haven't consumed the entire path, so we need to look at a child\\n\\t\\t\\t//         uint8 nibble = uint8(mptKey[mptKeyOffset]);\\n\\t\\t\\t//         mptKeyOffset += 1;\\n\\t\\t\\t//         if (nibble >= 16) {\\n\\t\\t\\t//             // each element of the path has to be a nibble\\n\\t\\t\\t//             revert();\\n\\t\\t\\t//         }\\n\\n\\t\\t\\t//         if (_isEmptyBytesequence(node[nibble])) {\\n\\t\\t\\t//             // Sanity\\n\\t\\t\\t//             if (i != stack.length - 1) {\\n\\t\\t\\t//                 // leaf node should be at last level\\n\\t\\t\\t//                 revert();\\n\\t\\t\\t//             }\\n\\n\\t\\t\\t//             return new bytes(0);\\n\\t\\t\\t//         } else if (!node[nibble].isList()) {\\n\\t\\t\\t//             nodeHashHash = node[nibble].payloadKeccak256();\\n\\t\\t\\t//         } else {\\n\\t\\t\\t//             nodeHashHash = node[nibble].rlpBytesKeccak256();\\n\\t\\t\\t//         }\\n\\t\\t\\t//     } else {\\n\\t\\t\\t//         // we have consumed the entire mptKey, so we need to look at what's contained in this node.\\n\\n\\t\\t\\t//         // Sanity\\n\\t\\t\\t//         if (i != stack.length - 1) {\\n\\t\\t\\t//             // should be at last level\\n\\t\\t\\t//             revert();\\n\\t\\t\\t//         }\\n\\n\\t\\t\\t//         return node[16].toBytes();\\n\\t\\t\\t//     }\\n\\t\\t\\t// }\\n\\t\\t}\\n\\t\\treturn \\\"42\\\";\\n\\t}\\n\\n\\t/// @dev Computes the hash of the Merkle-Patricia-Trie hash of the RLP item.\\n\\t///      Merkle-Patricia-Tries use a weird 'hash function' that outputs\\n\\t///      *variable-length* hashes: If the item is shorter than 32 bytes,\\n\\t///      the MPT hash is the item. Otherwise, the MPT hash is the\\n\\t///      Keccak-256 hash of the item.\\n\\t///      The easiest way to compare variable-length byte sequences is\\n\\t///      to compare their Keccak-256 hashes.\\n\\t/// @param item The RLP item to be hashed.\\n\\t/// @return Keccak-256(MPT-hash(item))\\n\\tfunction _mptHashHash(\\n\\t\\tRLPReader.RLPItem memory item\\n\\t) private pure returns (bytes32) {\\n\\t\\tif (item.len < 32) {\\n\\t\\t\\treturn item.rlpBytesKeccak256();\\n\\t\\t} else {\\n\\t\\t\\treturn keccak256(abi.encodePacked(item.rlpBytesKeccak256()));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _isEmptyBytesequence(\\n\\t\\tRLPReader.RLPItem memory item\\n\\t) private pure returns (bool) {\\n\\t\\tif (item.len != 1) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tuint8 b;\\n\\t\\tuint256 memPtr = item.memPtr;\\n\\t\\tassembly {\\n\\t\\t\\tb := byte(0, mload(memPtr))\\n\\t\\t}\\n\\t\\treturn b == 0x80; /* empty byte string */\\n\\t}\\n\\n\\tfunction _merklePatriciaCompactDecode(\\n\\t\\tbytes memory compact\\n\\t) private pure returns (bool isLeaf, bytes memory nibbles) {\\n\\t\\trequire(compact.length > 0);\\n\\t\\tuint256 first_nibble = (uint8(compact[0]) >> 4) & 0xF;\\n\\t\\tuint256 skipNibbles;\\n\\t\\tif (first_nibble == 0) {\\n\\t\\t\\tskipNibbles = 2;\\n\\t\\t\\tisLeaf = false;\\n\\t\\t} else if (first_nibble == 1) {\\n\\t\\t\\tskipNibbles = 1;\\n\\t\\t\\tisLeaf = false;\\n\\t\\t} else if (first_nibble == 2) {\\n\\t\\t\\tskipNibbles = 2;\\n\\t\\t\\tisLeaf = true;\\n\\t\\t} else if (first_nibble == 3) {\\n\\t\\t\\tskipNibbles = 1;\\n\\t\\t\\tisLeaf = true;\\n\\t\\t} else {\\n\\t\\t\\t// Not supposed to happen!\\n\\t\\t\\trevert();\\n\\t\\t}\\n\\t\\treturn (isLeaf, _decodeNibbles(compact, skipNibbles));\\n\\t}\\n\\n\\tfunction _decodeNibbles(\\n\\t\\tbytes memory compact,\\n\\t\\tuint256 skipNibbles\\n\\t) private pure returns (bytes memory nibbles) {\\n\\t\\trequire(compact.length > 0);\\n\\n\\t\\tuint256 length = compact.length * 2;\\n\\t\\trequire(skipNibbles <= length);\\n\\t\\tlength -= skipNibbles;\\n\\n\\t\\tnibbles = new bytes(length);\\n\\t\\tuint256 nibblesLength = 0;\\n\\n\\t\\tfor (uint256 i = skipNibbles; i < skipNibbles + length; i += 1) {\\n\\t\\t\\tif (i % 2 == 0) {\\n\\t\\t\\t\\tnibbles[nibblesLength] = bytes1(\\n\\t\\t\\t\\t\\t(uint8(compact[i / 2]) >> 4) & 0xF\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnibbles[nibblesLength] = bytes1(\\n\\t\\t\\t\\t\\t(uint8(compact[i / 2]) >> 0) & 0xF\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tnibblesLength += 1;\\n\\t\\t}\\n\\n\\t\\tassert(nibblesLength == nibbles.length);\\n\\t}\\n\\n\\tfunction _sharedPrefixLength(\\n\\t\\tuint256 xsOffset,\\n\\t\\tbytes memory xs,\\n\\t\\tbytes memory ys\\n\\t) private pure returns (uint256) {\\n\\t\\tuint256 i;\\n\\t\\tfor (i = 0; i + xsOffset < xs.length && i < ys.length; i++) {\\n\\t\\t\\tif (xs[i + xsOffset] != ys[i]) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn i;\\n\\t}\\n}\\n\",\"keccak256\":\"0xc62a6a78824b179f40c206c903f13d9fbf7c6d5b0bdbacae6f9521e0ab4f37ef\"},\"contracts/Prover.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { RLPReader } from \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\nimport { MerklePatriciaProofVerifier } from \\\".//MerklePatriciaProofVerifier.sol\\\";\\n\\ninterface IGiriGiriBashi {\\n\\tfunction getThresholdHash(\\n\\t\\tuint256 domain,\\n\\t\\tuint256 id\\n\\t) external view returns (bytes32);\\n}\\n\\ninterface IProver {\\n\\terror InvalidLatestCommitment(\\n\\t\\tbytes32 latestCommitment,\\n\\t\\tbytes32 expectedLatestCommitment\\n\\t);\\n\\terror InvalidBlockHeader(\\n\\t\\tbytes32 blockHeaderHash,\\n\\t\\tbytes32 expectedBlockHeaderHash\\n\\t);\\n\\terror InvalidAccountStorageRoot();\\n\\terror InvalidNonce(uint256 nonce, uint256 expectedNonce);\\n\\terror InvalidAccountRlp(bytes accountRlp);\\n\\n\\tstruct Proof {\\n\\t\\tuint256 blockNumber;\\n\\t\\tuint256 nonce;\\n\\t\\t// bytes blockHeader;\\n\\t\\tbytes32 storageRoot;\\n\\t\\t// bytes accountProof;\\n\\t\\tbytes storageProof;\\n\\t}\\n\\n\\tfunction setAccount(address account) external;\\n}\\n\\ncontract Prover is IProver {\\n\\tusing RLPReader for RLPReader.RLPItem;\\n\\tusing RLPReader for bytes;\\n\\n\\tuint256 public immutable SOURCE_CHAIN_ID;\\n\\tuint256 public immutable COMMITMENTS_SLOT;\\n\\taddress public ACCOUNT;\\n\\taddress public immutable GIRI_GIRI_BASHI;\\n\\n\\tuint256 public expectedNonce;\\n\\n\\tconstructor(\\n\\t\\tuint256 sourceChainId,\\n\\t\\tuint256 commitmentsSlot,\\n\\t\\taddress giriGiriBashi\\n\\t) {\\n\\t\\tSOURCE_CHAIN_ID = sourceChainId;\\n\\t\\tCOMMITMENTS_SLOT = commitmentsSlot;\\n\\t\\tGIRI_GIRI_BASHI = giriGiriBashi;\\n\\t}\\n\\n\\t// @inheritdoc IProver\\n\\tfunction setAccount(address account) external {\\n\\t\\tACCOUNT = account;\\n\\t}\\n\\n\\tfunction _verifyProof(\\n\\t\\tProof calldata proof,\\n\\t\\tbytes memory data\\n\\t) public returns (bool) {\\n\\t\\t// bytes32 expectedBlockHeaderHash = IGiriGiriBashi(GIRI_GIRI_BASHI)\\n\\t\\t// \\t.getThresholdHash(SOURCE_CHAIN_ID, proof.blockNumber);\\n\\t\\t// bytes32 blockHeaderHash = keccak256(proof.blockHeader);\\n\\t\\t// if (expectedBlockHeaderHash != blockHeaderHash)\\n\\t\\t// \\trevert InvalidBlockHeader(blockHeaderHash, expectedBlockHeaderHash);\\n\\n\\t\\t// bytes32 expectedLatestCommitment = _verifyStorageProofAndGetValue(\\n\\t\\t// \\t_verifyAccountProofAndGetStorageRoot(\\n\\t\\t// \\t\\tproof.blockHeader,\\n\\t\\t// \\t\\tproof.accountProof\\n\\t\\t// \\t),\\n\\t\\t// \\tproof.storageProof\\n\\t\\t// );\\n\\t\\tbytes32 expectedLatestCommitment = _verifyStorageProofAndGetValue(\\n\\t\\t\\tproof.storageRoot,\\n\\t\\t\\tproof.storageProof\\n\\t\\t);\\n\\t\\tbytes32 latestCommitment = keccak256(\\n\\t\\t\\tabi.encode(block.chainid, data, proof.nonce)\\n\\t\\t);\\n\\t\\tif (expectedLatestCommitment != latestCommitment) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// _checkNonceAndIncrementExpectedNonce(proof.nonce);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// function _verifyAccountProofAndGetStorageRoot(\\n\\t// \\tbytes memory blockHeader,\\n\\t// \\tbytes memory accountProof\\n\\t// ) internal view returns (bytes32) {\\n\\t// \\tRLPReader.RLPItem[] memory blockHeaderFields = blockHeader\\n\\t// \\t\\t.toRlpItem()\\n\\t// \\t\\t.toList();\\n\\t// \\tbytes32 stateRoot = bytes32(blockHeaderFields[3].toUint());\\n\\t// \\tbytes memory accountRlp = MerklePatriciaProofVerifier.extractProofValue(\\n\\t// \\t\\tstateRoot,\\n\\t// \\t\\tabi.encodePacked(keccak256(abi.encodePacked(ACCOUNT))),\\n\\t// \\t\\taccountProof.toRlpItem().toList()\\n\\t// \\t);\\n\\t// \\tbytes32 accountStorageRoot = bytes32(\\n\\t// \\t\\taccountRlp.toRlpItem().toList()[2].toUint()\\n\\t// \\t);\\n\\t// \\tif (accountStorageRoot.length == 0) revert InvalidAccountStorageRoot();\\n\\t// \\tRLPReader.RLPItem[] memory accountFields = accountRlp\\n\\t// \\t\\t.toRlpItem()\\n\\t// \\t\\t.toList();\\n\\t// \\tif (accountFields.length != 4) revert InvalidAccountRlp(accountRlp); // [nonce, balance, storageRoot, codeHash]\\n\\t// \\treturn bytes32(accountFields[2].toUint());\\n\\t// }\\n\\n\\tfunction _verifyStorageProofAndGetValue(\\n\\t\\tbytes32 storageRoot,\\n\\t\\tbytes calldata storageProof\\n\\t) internal view returns (bytes32) {\\n\\t\\tbytes memory slotValue = MerklePatriciaProofVerifier.extractProofValue(\\n\\t\\t\\tstorageRoot,\\n\\t\\t\\t// abi.encodePacked(\\n\\t\\t\\t// \\tkeccak256(\\n\\t\\t\\t// \\t\\tabi.encode(\\n\\t\\t\\t// \\t\\t\\tkeccak256(abi.encode(msg.sender, COMMITMENTS_SLOT))\\n\\t\\t\\t// \\t\\t)\\n\\t\\t\\t// \\t)\\n\\t\\t\\t// ),\\n            abi.encodePacked(keccak256(abi.encodePacked(uint256(0)))),\\n\\t\\t\\tstorageProof.toRlpItem().toList()\\n\\t\\t);\\n\\t\\treturn _bytesToBytes32(slotValue);\\n\\t}\\n\\n\\tfunction _checkNonceAndIncrementExpectedNonce(uint256 nonce) internal {\\n\\t\\tif (nonce != expectedNonce) revert InvalidNonce(nonce, expectedNonce);\\n\\t\\tunchecked {\\n\\t\\t\\t++expectedNonce;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _bytesToBytes32(\\n\\t\\tbytes memory source\\n\\t) internal pure returns (bytes32 result) {\\n\\t\\tif (source.length == 0) {\\n\\t\\t\\treturn bytes32(0);\\n\\t\\t}\\n\\t\\t// solhint-disable-next-line\\n\\t\\tassembly {\\n\\t\\t\\tresult := mload(add(add(source, 1), 32))\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x07d81978d8bbde99dd4d4220858ec42c1d76837d1ceabb457ae17c1d6e93e8df\",\"license\":\"MIT\"},\"solidity-rlp/contracts/RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity >=0.5.10 <0.9.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3a44f2de3c752fa4f926f3fd4cad8338dab742484150c0d7d2f785409ed8db4d\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60e03461009057601f610c1c38819003918201601f19168301916001600160401b0383118484101761009557808492606094604052833981010312610090578051602082015160409092015191906001600160a01b03831683036100905760805260a05260c052604051610b7090816100ac823960805181610282015260a05181610247015260c051816102d20152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe6080604052600436101561001257600080fd5b6000803560e01c90816329f6d57c1461008a5750806331a5bd901461008557806332b55cbf1461008057806374be21501461007b578063cb7cf18114610076578063e90524f2146100715763ebe445fc1461006c57600080fd5b61032a565b6102f6565b6102a5565b61026a565b61022f565b6101ad565b346100ea5760203660031901126100ea5760043573ffffffffffffffffffffffffffffffffffffffff81168091036100e6577fffffffffffffffffffffffff000000000000000000000000000000000000000082541617815580f35b5080fd5b80fd5b634e487b7160e01b600052604160045260246000fd5b6040810190811067ffffffffffffffff82111761011f57604052565b6100ed565b90601f8019910116810190811067ffffffffffffffff82111761011f57604052565b6040519061015382610103565b565b67ffffffffffffffff811161011f57601f01601f191660200190565b92919261017d82610155565b9161018b6040519384610124565b8294818452818301116101a8578281602093846000960137010152565b600080fd5b346101a8576003196040368201126101a8576004359067ffffffffffffffff908183116101a85760809083360301126101a8576024359081116101a857366023820112156101a85761022b91610210610219923690602481600401359101610171565b9060040161039c565b60405190151581529081906020820190565b0390f35b346101a85760003660031901126101a85760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101a85760003660031901126101a85760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101a85760003660031901126101a857602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346101a85760003660031901126101a857602073ffffffffffffffffffffffffffffffffffffffff60005416604051908152f35b346101a85760003660031901126101a8576020600154604051908152f35b939291908452602060608186015281519182606087015260005b8381106103885750505060808160008260409488010152601f8019910116850101930152565b818101830151878201608001528201610362565b6060810135601e19823603018112156101a857810180359067ffffffffffffffff82116101a8576020019080360382136101a8576103e561040a916103fc93604086013561041c565b936040519283916020808401960135904687610348565b03601f198101835282610124565b5190200361041757600190565b600090565b91909161045c60405193602094858101906000825286815261043d81610103565b51902093604051948686015285855261045585610103565b3691610171565b92610465610563565b5083516040519061047582610103565b81528180820195018552610488816109d6565b156101a857610496906109f2565b906104a0826109be565b946104ae6040519687610124565b828652601f196104bd846109be565b018260005b82811061054d575050506104e090516104da81610ada565b90610870565b6000905b8382106105055750505050916104fd916105029361067d565b6109aa565b90565b6105418161051561054793610a54565b9061051e610146565b8281528187820152610530868c610630565b5261053b858b610630565b50610870565b916105f4565b906104e4565b610555610563565b82828b0101520183906104c2565b6040519061057082610103565b60006020838281520152565b156101a857565b6040516020810181811067ffffffffffffffff82111761011f5760405260008152906000368137565b906105b682610155565b6105c36040519182610124565b82815280926105d4601f1991610155565b0190602036910137565b634e487b7160e01b600052601160045260246000fd5b60001981146106035760010190565b6105de565b634e487b7160e01b600052603260045260246000fd5b80511561062b5760200190565b610608565b805182101561062b5760209160051b010190565b6040519061065182610103565b600282527f34320000000000000000000000000000000000000000000000000000000000006020830152565b929190610689906108ab565b50610692610563565b508051156107a057600092835b82518110156107935780158080610771575b6106ec5715806106d2575b6106ce576106c9906105f4565b61069f565b8480fd5b506106e56106df8461061e565b516107d5565b15156106bc565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f526f6f74206861736820646f6573206e6f74206d61746368207468652066697260448201527f73742070726f6f6620656c656d656e74000000000000000000000000000000006064820152608490fd5b5061078b61077e8561061e565b5160208101519051902090565b8314156106b1565b5050509050610502610644565b50907f56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b4216107cd911461057c565b610502610583565b805160208110156107ed575060208101519051902090565b906020015120604051602081019182526020815261080a81610103565b51902090565b908160011b918083046002149015171561060357565b60bf1981019190821161060357565b607f1981019190821161060357565b60f61981019190821161060357565b60b61981019190821161060357565b906001820180921161060357565b9190820180921161060357565b90815181101561062b570160200190565b1561089557565b634e487b7160e01b600052600160045260246000fd5b906108c182516108bc81151561057c565b610810565b916108cb836105ac565b9260009081925b8184106108e8575050610153915083511461088e565b9091610981610987917f0f000000000000000000000000000000000000000000000000000000000000008660018082161560001461098f5761095b61093561096a93610961931c8961087d565b517fff000000000000000000000000000000000000000000000000000000000000001690565b60f81c90565b60041c600f1690565b60f81b1660001a61097b828a61087d565b53610862565b93610862565b9291906108d2565b61095b61093561096a936109a4931c8961087d565b60ff1690565b8051156109b8576021015190565b50600090565b67ffffffffffffffff811161011f5760051b60200190565b8051156109b857602060c09101515160001a1061041757600190565b8051156109b85760009060208101908151610a0c81610ada565b8101809111610603579151905181018091116106035791905b828110610a325750905090565b610a3b81610a54565b810180911161060357610a4e90916105f4565b90610a25565b805160001a906080821015610a6a575050600190565b60b8821015610a855750610a8061050291610835565b610862565b9060c0811015610aa95760b51991600160b783602003016101000a91015104010190565b9060f8821015610ac05750610a8061050291610826565b60010151602082900360f7016101000a90040160f5190190565b5160001a6080811015610aed5750600090565b60b881108015610b24575b15610b035750600190565b60c0811015610b1857610a8061050291610853565b610a8061050291610844565b5060c08110158015610af8575060f88110610af856fea264697066735822122022e7514a07890c45f26b35c133cc81e4f49a6004e59ab1d2155f03135ef5c5dd64736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436101561001257600080fd5b6000803560e01c90816329f6d57c1461008a5750806331a5bd901461008557806332b55cbf1461008057806374be21501461007b578063cb7cf18114610076578063e90524f2146100715763ebe445fc1461006c57600080fd5b61032a565b6102f6565b6102a5565b61026a565b61022f565b6101ad565b346100ea5760203660031901126100ea5760043573ffffffffffffffffffffffffffffffffffffffff81168091036100e6577fffffffffffffffffffffffff000000000000000000000000000000000000000082541617815580f35b5080fd5b80fd5b634e487b7160e01b600052604160045260246000fd5b6040810190811067ffffffffffffffff82111761011f57604052565b6100ed565b90601f8019910116810190811067ffffffffffffffff82111761011f57604052565b6040519061015382610103565b565b67ffffffffffffffff811161011f57601f01601f191660200190565b92919261017d82610155565b9161018b6040519384610124565b8294818452818301116101a8578281602093846000960137010152565b600080fd5b346101a8576003196040368201126101a8576004359067ffffffffffffffff908183116101a85760809083360301126101a8576024359081116101a857366023820112156101a85761022b91610210610219923690602481600401359101610171565b9060040161039c565b60405190151581529081906020820190565b0390f35b346101a85760003660031901126101a85760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101a85760003660031901126101a85760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101a85760003660031901126101a857602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346101a85760003660031901126101a857602073ffffffffffffffffffffffffffffffffffffffff60005416604051908152f35b346101a85760003660031901126101a8576020600154604051908152f35b939291908452602060608186015281519182606087015260005b8381106103885750505060808160008260409488010152601f8019910116850101930152565b818101830151878201608001528201610362565b6060810135601e19823603018112156101a857810180359067ffffffffffffffff82116101a8576020019080360382136101a8576103e561040a916103fc93604086013561041c565b936040519283916020808401960135904687610348565b03601f198101835282610124565b5190200361041757600190565b600090565b91909161045c60405193602094858101906000825286815261043d81610103565b51902093604051948686015285855261045585610103565b3691610171565b92610465610563565b5083516040519061047582610103565b81528180820195018552610488816109d6565b156101a857610496906109f2565b906104a0826109be565b946104ae6040519687610124565b828652601f196104bd846109be565b018260005b82811061054d575050506104e090516104da81610ada565b90610870565b6000905b8382106105055750505050916104fd916105029361067d565b6109aa565b90565b6105418161051561054793610a54565b9061051e610146565b8281528187820152610530868c610630565b5261053b858b610630565b50610870565b916105f4565b906104e4565b610555610563565b82828b0101520183906104c2565b6040519061057082610103565b60006020838281520152565b156101a857565b6040516020810181811067ffffffffffffffff82111761011f5760405260008152906000368137565b906105b682610155565b6105c36040519182610124565b82815280926105d4601f1991610155565b0190602036910137565b634e487b7160e01b600052601160045260246000fd5b60001981146106035760010190565b6105de565b634e487b7160e01b600052603260045260246000fd5b80511561062b5760200190565b610608565b805182101561062b5760209160051b010190565b6040519061065182610103565b600282527f34320000000000000000000000000000000000000000000000000000000000006020830152565b929190610689906108ab565b50610692610563565b508051156107a057600092835b82518110156107935780158080610771575b6106ec5715806106d2575b6106ce576106c9906105f4565b61069f565b8480fd5b506106e56106df8461061e565b516107d5565b15156106bc565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f526f6f74206861736820646f6573206e6f74206d61746368207468652066697260448201527f73742070726f6f6620656c656d656e74000000000000000000000000000000006064820152608490fd5b5061078b61077e8561061e565b5160208101519051902090565b8314156106b1565b5050509050610502610644565b50907f56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b4216107cd911461057c565b610502610583565b805160208110156107ed575060208101519051902090565b906020015120604051602081019182526020815261080a81610103565b51902090565b908160011b918083046002149015171561060357565b60bf1981019190821161060357565b607f1981019190821161060357565b60f61981019190821161060357565b60b61981019190821161060357565b906001820180921161060357565b9190820180921161060357565b90815181101561062b570160200190565b1561089557565b634e487b7160e01b600052600160045260246000fd5b906108c182516108bc81151561057c565b610810565b916108cb836105ac565b9260009081925b8184106108e8575050610153915083511461088e565b9091610981610987917f0f000000000000000000000000000000000000000000000000000000000000008660018082161560001461098f5761095b61093561096a93610961931c8961087d565b517fff000000000000000000000000000000000000000000000000000000000000001690565b60f81c90565b60041c600f1690565b60f81b1660001a61097b828a61087d565b53610862565b93610862565b9291906108d2565b61095b61093561096a936109a4931c8961087d565b60ff1690565b8051156109b8576021015190565b50600090565b67ffffffffffffffff811161011f5760051b60200190565b8051156109b857602060c09101515160001a1061041757600190565b8051156109b85760009060208101908151610a0c81610ada565b8101809111610603579151905181018091116106035791905b828110610a325750905090565b610a3b81610a54565b810180911161060357610a4e90916105f4565b90610a25565b805160001a906080821015610a6a575050600190565b60b8821015610a855750610a8061050291610835565b610862565b9060c0811015610aa95760b51991600160b783602003016101000a91015104010190565b9060f8821015610ac05750610a8061050291610826565b60010151602082900360f7016101000a90040160f5190190565b5160001a6080811015610aed5750600090565b60b881108015610b24575b15610b035750600190565b60c0811015610b1857610a8061050291610853565b610a8061050291610844565b5060c08110158015610af8575060f88110610af856fea264697066735822122022e7514a07890c45f26b35c133cc81e4f49a6004e59ab1d2155f03135ef5c5dd64736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 653,
        "contract": "contracts/Prover.sol:Prover",
        "label": "ACCOUNT",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 657,
        "contract": "contracts/Prover.sol:Prover",
        "label": "expectedNonce",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}