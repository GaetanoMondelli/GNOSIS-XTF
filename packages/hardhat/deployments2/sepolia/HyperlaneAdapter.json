{
  "address": "0x6869B0EbdC183Ab4cFc297B32214B21A417E76B2",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "hyperlaneMailbox",
          "type": "address"
        },
        {
          "internalType": "contract IInterchainSecurityModule",
          "name": "_securityModule",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "blockNumber",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "blockHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "storedBlockHash",
          "type": "bytes32"
        }
      ],
      "name": "ConflictingBlockHeader",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "name": "InvalidBlockHeaderLength",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidBlockHeaderRLP",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnauthorizedHyperlaneReceive",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "hash",
          "type": "bytes32"
        }
      ],
      "name": "HashStored",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "reporter",
          "type": "bytes32"
        }
      ],
      "name": "ReporterSet",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "HYPERLANE_MAILBOX",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PROVIDER",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "name": "chainIds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "name": "enabledReporters",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "domain",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "getHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "origin",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "sender",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "handle",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "interchainSecurityModule",
      "outputs": [
        {
          "internalType": "contract IInterchainSecurityModule",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "bytes[]",
          "name": "blockHeaders",
          "type": "bytes[]"
        }
      ],
      "name": "proveAncestralBlockHashes",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "securityModule",
      "outputs": [
        {
          "internalType": "contract IInterchainSecurityModule",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "reporter",
          "type": "bytes32"
        }
      ],
      "name": "setReporterByChain",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xc95076d3db7dc9391264c45ca97a225e2e5fa98c5a042dfa09ee2dc7c5fecedf",
  "receipt": {
    "to": null,
    "from": "0x2a1F5eB3e84e58e6F1e565306298B9dE1273f203",
    "contractAddress": "0x6869B0EbdC183Ab4cFc297B32214B21A417E76B2",
    "transactionIndex": 22,
    "gasUsed": "875249",
    "logsBloom": "0x00200000000000000000000000040000000000000000000000800000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000200000000000000000000000000000000000000000000",
    "blockHash": "0x83c99f1d8569271b52965040baa63903ee7674fc62b2bd3230314cbde49087a3",
    "transactionHash": "0xc95076d3db7dc9391264c45ca97a225e2e5fa98c5a042dfa09ee2dc7c5fecedf",
    "logs": [
      {
        "transactionIndex": 22,
        "blockNumber": 5740033,
        "transactionHash": "0xc95076d3db7dc9391264c45ca97a225e2e5fa98c5a042dfa09ee2dc7c5fecedf",
        "address": "0x6869B0EbdC183Ab4cFc297B32214B21A417E76B2",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000002a1f5eb3e84e58e6f1e565306298b9de1273f203"
        ],
        "data": "0x",
        "logIndex": 28,
        "blockHash": "0x83c99f1d8569271b52965040baa63903ee7674fc62b2bd3230314cbde49087a3"
      }
    ],
    "blockNumber": 5740033,
    "cumulativeGasUsed": "5536373",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xfFAEF09B3cd11D9b20d1a19bECca54EEC2884766",
    "0xa717195377ad63B5EF830548492878ED9A1528D0"
  ],
  "numDeployments": 2,
  "solcInputHash": "bfafa734c4c6b5f46d9d0a7a2a8cfcda",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hyperlaneMailbox\",\"type\":\"address\"},{\"internalType\":\"contract IInterchainSecurityModule\",\"name\":\"_securityModule\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"storedBlockHash\",\"type\":\"bytes32\"}],\"name\":\"ConflictingBlockHeader\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"InvalidBlockHeaderLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBlockHeaderRLP\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedHyperlaneReceive\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"HashStored\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"reporter\",\"type\":\"bytes32\"}],\"name\":\"ReporterSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HYPERLANE_MAILBOX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROVIDER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"chainIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"enabledReporters\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"domain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"origin\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"handle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchainSecurityModule\",\"outputs\":[{\"internalType\":\"contract IInterchainSecurityModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"blockHeaders\",\"type\":\"bytes[]\"}],\"name\":\"proveAncestralBlockHashes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"securityModule\",\"outputs\":[{\"internalType\":\"contract IInterchainSecurityModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"reporter\",\"type\":\"bytes32\"}],\"name\":\"setReporterByChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"HashStored(uint256,bytes32)\":{\"details\":\"Emitted when a hash is stored.\",\"params\":{\"hash\":\"- The stored hash as bytes32 values.\",\"id\":\"- The ID of the stored hash.\"}}},\"kind\":\"dev\",\"methods\":{\"getHash(uint256,uint256)\":{\"details\":\"Returns the hash for a given ID.\",\"params\":{\"domain\":\"- Identifier for the domain to query.\",\"id\":\"- Identifier for the ID to query.\"},\"returns\":{\"_0\":\"Bytes32 hash for the given ID on the given domain.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"proveAncestralBlockHashes(uint256,bytes[])\":{\"details\":\"Proves and stores valid ancestral block hashes for a given chain ID.\",\"params\":{\"blockHeaders\":\"- The RLP encoded block headers to prove the hashes for.\",\"chainId\":\"- The ID of the chain to prove block hashes for.\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getHash(uint256,uint256)\":{\"notice\":\"MUST return bytes32(0) if the hash is not present.\"},\"proveAncestralBlockHashes(uint256,bytes[])\":{\"notice\":\"Block headers should be ordered by descending block number and should start with a known block header.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/adapeters/Hyperlane/HyperlaneAdapter.sol\":\"HyperlaneAdapter\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@hyperlane-xyz/core/contracts/interfaces/IInterchainSecurityModule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\ninterface IInterchainSecurityModule {\\n    enum Types {\\n        UNUSED,\\n        ROUTING,\\n        AGGREGATION,\\n        LEGACY_MULTISIG,\\n        MERKLE_ROOT_MULTISIG,\\n        MESSAGE_ID_MULTISIG,\\n        NULL, // used with relayer carrying no metadata\\n        CCIP_READ\\n    }\\n\\n    /**\\n     * @notice Returns an enum that represents the type of security model\\n     * encoded by this ISM.\\n     * @dev Relayers infer how to fetch and format metadata.\\n     */\\n    function moduleType() external view returns (uint8);\\n\\n    /**\\n     * @notice Defines a security model responsible for verifying interchain\\n     * messages based on the provided metadata.\\n     * @param _metadata Off-chain metadata provided by a relayer, specific to\\n     * the security model encoded by the module (e.g. validator signatures)\\n     * @param _message Hyperlane encoded interchain message\\n     * @return True if the message was verified\\n     */\\n    function verify(\\n        bytes calldata _metadata,\\n        bytes calldata _message\\n    ) external returns (bool);\\n}\\n\\ninterface ISpecifiesInterchainSecurityModule {\\n    function interchainSecurityModule()\\n        external\\n        view\\n        returns (IInterchainSecurityModule);\\n}\\n\",\"keccak256\":\"0xd144a00a15eef18012f8dae28ca1a7d965012f88ff4a07382a172ae6e02811ce\",\"license\":\"MIT OR Apache-2.0\"},\"@hyperlane-xyz/core/contracts/interfaces/IMessageRecipient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\ninterface IMessageRecipient {\\n    function handle(\\n        uint32 _origin,\\n        bytes32 _sender,\\n        bytes calldata _message\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x145e8332a91295a710deb3cb1ab689144262ef6ec66d9570c600b778e9dd964d\",\"license\":\"MIT OR Apache-2.0\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa94b34880e3c1b0b931662cb1c09e5dfa6662f31cba80e07c5ee71cd135c9673\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/adapeters/Adapter.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.20;\\n\\nimport { IAdapter } from \\\"../interfaces/IAdapter.sol\\\";\\n\\nabstract contract Adapter is IAdapter {\\n    mapping(uint256 => mapping(uint256 => bytes32)) private _hashes;\\n\\n    /// @inheritdoc IAdapter\\n    function getHash(uint256 domain, uint256 id) public view returns (bytes32) {\\n        return _hashes[domain][id];\\n    }\\n\\n    function _storeHashes(uint256 domain, uint256[] memory ids, bytes32[] memory hashes) internal {\\n        for (uint256 i = 0; i < ids.length; ) {\\n            _storeHash(domain, ids[i], hashes[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _storeHash(uint256 domain, uint256 id, bytes32 hash) internal {\\n        bytes32 currentHash = _hashes[domain][id];\\n        if (currentHash != hash) {\\n            _hashes[domain][id] = hash;\\n            emit HashStored(id, hash);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x06ea7188d8900e768d2e272d25e11a9b851a9b10bab80ead24735aade5dd6644\",\"license\":\"LGPL-3.0-only\"},\"contracts/adapeters/BlockHashAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.20;\\n\\nimport { RLPReader } from \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\nimport { Adapter } from \\\"./Adapter.sol\\\";\\nimport { IBlockHashAdapter } from \\\"../interfaces/IBlockHashAdapter.sol\\\";\\n\\nabstract contract BlockHashAdapter is IBlockHashAdapter, Adapter {\\n    using RLPReader for RLPReader.RLPItem;\\n\\n    /// @inheritdoc IBlockHashAdapter\\n    function proveAncestralBlockHashes(uint256 chainId, bytes[] memory blockHeaders) external {\\n        for (uint256 i = 0; i < blockHeaders.length; i++) {\\n            RLPReader.RLPItem memory blockHeaderRLP = RLPReader.toRlpItem(blockHeaders[i]);\\n\\n            if (!blockHeaderRLP.isList()) revert InvalidBlockHeaderRLP();\\n\\n            RLPReader.RLPItem[] memory blockHeaderContent = blockHeaderRLP.toList();\\n\\n            // A block header should have between 15 and 17 elements (baseFee and withdrawalsRoot have been added later)\\n            if (blockHeaderContent.length < 15 || blockHeaderContent.length > 17)\\n                revert InvalidBlockHeaderLength(blockHeaderContent.length);\\n\\n            bytes32 blockParent = bytes32(blockHeaderContent[0].toUint());\\n            uint256 blockNumber = uint256(blockHeaderContent[8].toUint());\\n\\n            bytes32 blockHash = keccak256(blockHeaders[i]);\\n            bytes32 storedBlockHash = getHash(chainId, blockNumber);\\n\\n            if (blockHash != storedBlockHash) revert ConflictingBlockHeader(blockNumber, blockHash, storedBlockHash);\\n\\n            _storeHash(chainId, blockNumber - 1, blockParent);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7108e898c79499e13cfa255a6eb5ab19602a8200443da713d2bc60b89bde2598\",\"license\":\"LGPL-3.0-only\"},\"contracts/adapeters/Hyperlane/HyperlaneAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.20;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IMessageRecipient } from \\\"@hyperlane-xyz/core/contracts/interfaces/IMessageRecipient.sol\\\";\\nimport { IInterchainSecurityModule, ISpecifiesInterchainSecurityModule } from \\\"@hyperlane-xyz/core/contracts/interfaces/IInterchainSecurityModule.sol\\\";\\nimport { BlockHashAdapter } from \\\"../BlockHashAdapter.sol\\\";\\n\\ncontract HyperlaneAdapter is BlockHashAdapter, Ownable, IMessageRecipient, ISpecifiesInterchainSecurityModule {\\n\\tstring public constant PROVIDER = \\\"hyperlane\\\";\\n\\n\\taddress public immutable HYPERLANE_MAILBOX;\\n\\n    IInterchainSecurityModule public immutable securityModule;\\n\\n\\tmapping(uint32 => bytes32) public enabledReporters;\\n\\tmapping(uint32 => uint256) public chainIds;\\n\\n\\terror UnauthorizedHyperlaneReceive();\\n\\n\\tevent ReporterSet(\\n\\t\\tuint256 indexed chainId,\\n\\t\\tuint32 indexed domain,\\n\\t\\tbytes32 indexed reporter\\n\\t);\\n\\n\\n\\tconstructor(\\n\\t\\taddress hyperlaneMailbox,\\n\\t\\tIInterchainSecurityModule _securityModule\\n\\t) {\\n        securityModule = _securityModule;\\n\\t\\tHYPERLANE_MAILBOX = hyperlaneMailbox;\\n\\t}\\n\\n\\tfunction handle(\\n\\t\\tuint32 origin,\\n\\t\\tbytes32 sender,\\n\\t\\tbytes calldata message\\n\\t) external payable {\\n\\t\\tif (\\n\\t\\t\\tmsg.sender != HYPERLANE_MAILBOX ||\\n\\t\\t\\tenabledReporters[origin] != sender\\n\\t\\t) revert UnauthorizedHyperlaneReceive();\\n\\t\\tuint256 sourceChainId = chainIds[origin];\\n\\t\\t(uint256[] memory ids, bytes32[] memory hashes) = abi.decode(\\n\\t\\t\\tmessage,\\n\\t\\t\\t(uint256[], bytes32[])\\n\\t\\t);\\n\\t\\t_storeHashes(sourceChainId, ids, hashes);\\n\\t}\\n\\n\\tfunction setReporterByChain(\\n\\t\\tuint256 chainId,\\n\\t\\tuint32 domain,\\n\\t\\tbytes32 reporter\\n\\t) external onlyOwner {\\n\\t\\tenabledReporters[domain] = reporter;\\n\\t\\tchainIds[domain] = chainId;\\n\\t\\temit ReporterSet(chainId, domain, reporter);\\n\\t}\\n\\n\\tfunction interchainSecurityModule()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\toverride\\n\\t\\treturns (IInterchainSecurityModule)\\n\\t{\\n\\t\\treturn securityModule;\\n\\t}\\n}\\n\",\"keccak256\":\"0x39b8337ceec401a75ca467b91b311070bfd7dce4cb6d275bab85e78b57a22c32\",\"license\":\"LGPL-3.0-only\"},\"contracts/interfaces/IAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IAdapter\\n */\\ninterface IAdapter {\\n    error ConflictingBlockHeader(uint256 blockNumber, bytes32 blockHash, bytes32 storedBlockHash);\\n    error InvalidBlockHeaderLength(uint256 length);\\n    error InvalidBlockHeaderRLP();\\n\\n    /**\\n     * @dev Emitted when a hash is stored.\\n     * @param id - The ID of the stored hash.\\n     * @param hash - The stored hash as bytes32 values.\\n     */\\n    event HashStored(uint256 indexed id, bytes32 indexed hash);\\n\\n    /**\\n     * @dev Returns the hash for a given ID.\\n     * @param domain - Identifier for the domain to query.\\n     * @param id - Identifier for the ID to query.\\n     * @return hash Bytes32 hash for the given ID on the given domain.\\n     * @notice MUST return bytes32(0) if the hash is not present.\\n     */\\n    function getHash(uint256 domain, uint256 id) external view returns (bytes32 hash);\\n}\\n\",\"keccak256\":\"0xc3c6fca20c390f619072fe34bde40b91ceca4bbd1627a892af627b2e10f8a38d\",\"license\":\"LGPL-3.0-only\"},\"contracts/interfaces/IBlockHashAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport { IAdapter } from \\\"./IAdapter.sol\\\";\\n\\n/**\\n * @title IBlockHashAdapter\\n */\\ninterface IBlockHashAdapter is IAdapter {\\n    /**\\n     * @dev Proves and stores valid ancestral block hashes for a given chain ID.\\n     * @param chainId - The ID of the chain to prove block hashes for.\\n     * @param blockHeaders - The RLP encoded block headers to prove the hashes for.\\n     * @notice Block headers should be ordered by descending block number and should start with a known block header.\\n     */\\n    function proveAncestralBlockHashes(uint256 chainId, bytes[] memory blockHeaders) external;\\n}\\n\",\"keccak256\":\"0x460c447b1cb9483a912754a528396c2be7d90deaf5ab6b6063f8bdfae9274989\",\"license\":\"LGPL-3.0-only\"},\"solidity-rlp/contracts/RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity >=0.5.10 <0.9.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3a44f2de3c752fa4f926f3fd4cad8338dab742484150c0d7d2f785409ed8db4d\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60c0346100c857601f610f4e38819003918201601f19168301916001600160401b038311848410176100cd5780849260409485528339810103126100c85780516001600160a01b039182821682036100c8576020015182811681036100c85760018054336001600160a01b03198216811790925560405194167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a360a052608052610e6a90816100e482396080518181816102e00152610533015260a051816102520152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe6080604052600436101561001257600080fd5b60003560e01c8062d34411146100e15780631b855044146100dc578063380ef3fe146100b957806356d5d475146100d75780636558b681146100d2578063715018a6146100cd5780638da5cb5b146100c85780639c475207146100c3578063c751fbfb146100be578063de523cf3146100b9578063e53091b7146100b4578063e81900a6146100af5763f2fde38b146100aa57600080fd5b6106b1565b6105e3565b610557565b610232565b610513565b6104dc565b6104b5565b610449565b610412565b610289565b6101f8565b610163565b634e487b7160e01b600052604160045260246000fd5b604051906040820182811067ffffffffffffffff82111761011c57604052565b6100e6565b6040519190601f01601f1916820167ffffffffffffffff81118382101761011c57604052565b67ffffffffffffffff811161011c57601f01601f191660200190565b346101f35760003660031901126101f35761017c6100fc565b6009815260207f68797065726c616e650000000000000000000000000000000000000000000000818301526040908151928184928352815191828285015260005b8381106101dd575050600083830185015250601f01601f19168101030190f35b81810183015187820187015286945082016101bd565b600080fd5b346101f35760403660031901126101f357600435600052600060205260406000206024356000526020526020604060002054604051908152f35b346101f35760003660031901126101f35760206040516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b6004359063ffffffff821682036101f357565b60603660031901126101f35761029d610276565b60443567ffffffffffffffff8082116101f357366023830112156101f35781600401358181116101f35782019060248201903682116101f3576001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633148015906103f2575b6103c85763ffffffff60009516855260209160038352604085818820549503126103ad5760248501358281116103c457850192816043850112156103c45760248401359361035f61035a866105cb565b610121565b9460448387838152019160051b830101918483116103c057604401905b8282106103b1575050505060448501359182116103ad5760246103a4926103aa960101610aac565b91610b02565b80f35b8580fd5b8135815290830190830161037c565b8980fd5b8680fd5b60046040517ff920c49e000000000000000000000000000000000000000000000000000000008152fd5b5063ffffffff85166000526002602052602435604060002054141561030a565b346101f35760203660031901126101f35763ffffffff610430610276565b1660005260036020526020604060002054604051908152f35b346101f3576000806003193601126104b257610463610756565b806001600160a01b0360015473ffffffffffffffffffffffffffffffffffffffff198116600155167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b346101f35760003660031901126101f35760206001600160a01b0360015416604051908152f35b346101f35760203660031901126101f35763ffffffff6104fa610276565b1660005260026020526020604060002054604051908152f35b346101f35760003660031901126101f35760206040516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b346101f35760603660031901126101f35760043560243563ffffffff81168091036101f35760443590610588610756565b600092818452600260205282604085205560036020528060408520557f33650c025ba183d07fb1e4533c7f06438835fff96b46d07d6112ed2dda6149ba8480a480f35b67ffffffffffffffff811161011c5760051b60200190565b346101f35760403660031901126101f357602467ffffffffffffffff81358181116101f357366023820112156101f35780600401359261062561035a856105cb565b9384938186528260208097019260051b850101933685116101f357838101925b85841061065a57610658876004356108c5565b005b83358381116101f357820190366043830112156101f357858201359061068261035a83610147565b828152604493368585830101116101f3578b848196958296600094018386013783010152815201930192610645565b346101f35760203660031901126101f3576004356001600160a01b0381168082036101f3576106de610756565b156106ec57610658906107ae565b608460405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b6001600160a01b0360015416330361076a57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b600154906001600160a01b03809116918273ffffffffffffffffffffffffffffffffffffffff19821617600155167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3565b634e487b7160e01b600052601160045260246000fd5b60001981146108285760010190565b610803565b634e487b7160e01b600052603260045260246000fd5b8051156108505760200190565b61082d565b805160081015610850576101200190565b80518210156108505760209160051b010190565b60001981019190821161082857565b60bf1981019190821161082857565b607f1981019190821161082857565b60f61981019190821161082857565b60b61981019190821161082857565b91909160005b8351811015610a3e576108e76108e18286610866565b51610b57565b6108f76108f382610c65565b1590565b610a145761090490610b9c565b8051600f81108015610a0a575b6109d7575061093461092861092e61092884610843565b51610c8c565b92610855565b61093e8387610866565b516020815191012061096d8261095e876000526000602052604060002090565b90600052602052604060002090565b54808203610998575050610993929161098861098e9261087a565b85610a44565b610819565b6108cb565b6040517fc442fd2b0000000000000000000000000000000000000000000000000000000081526004810184905260248101929092526044820152606490fd5b6040517f9fd6e11c0000000000000000000000000000000000000000000000000000000081526004810191909152602490fd5b5060118111610911565b60046040517fe4508b9f000000000000000000000000000000000000000000000000000000008152fd5b50509050565b6000818152806020526040812083825260205283604082205403610a69575b50505050565b7f7c57815e36323391c63e53a2fe2969599eb6dbcf52484a3bd8909aef4a6704d7918152806020526040812083825260205283604082205580a338808080610a63565b9080601f830112156101f357813590610ac761035a836105cb565b9182938184526020808095019260051b8201019283116101f3578301905b828210610af3575050505090565b81358152908301908301610ae5565b92919060005b8151811015610b3a5780610b34610b2160019385610866565b51610b2c8387610866565b519088610a44565b01610b08565b5050509050565b610b496100fc565b906000825260006020830152565b60006020610b636100fc565b82815201526020815191610b756100fc565b92835201602082015290565b906001820180921161082857565b9190820180921161082857565b610ba581610c65565b156101f357610bb381610ceb565b610bbf61035a826105cb565b81815291601f19610bcf836105cb565b0160005b818110610c4e575050610bf4602080920151610bee81610dd4565b90610b8f565b6000905b838210610c06575050505090565b610c4281610c16610c4893610d4d565b90610c1f6100fc565b8281528187820152610c31868a610866565b52610c3c8589610866565b50610b8f565b91610819565b90610bf8565b602090610c59610b41565b82828801015201610bd3565b805115610c8657602060c09101515160001a10610c8157600190565b600090565b50600090565b80518015159081610cdf575b50156101f3576020810190610cad8251610dd4565b915190828201809211610828575191820391821161082857519060208110610cd3575090565b6020036101000a900490565b60219150111538610c98565b805115610c865760009060208101908151610d0581610dd4565b8101809111610828579151905181018091116108285791905b828110610d2b5750905090565b610d3481610d4d565b810180911161082857610d479091610819565b90610d1e565b805160001a906080821015610d6457505060015b90565b60b8821015610d7f5750610d7a610d6191610898565b610b81565b9060c0811015610da35760b51991600160b783602003016101000a91015104010190565b9060f8821015610dba5750610d7a610d6191610889565b60010151602082900360f7016101000a90040160f5190190565b5160001a6080811015610de75750600090565b60b881108015610e1e575b15610dfd5750600190565b60c0811015610e1257610d7a610d61916108b6565b610d7a610d61916108a7565b5060c08110158015610df2575060f88110610df256fea2646970667358221220ca283ed9ff50b4d52fdc9b1bb2f3681376274dad35a97cdbd72f60c0c70171df64736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436101561001257600080fd5b60003560e01c8062d34411146100e15780631b855044146100dc578063380ef3fe146100b957806356d5d475146100d75780636558b681146100d2578063715018a6146100cd5780638da5cb5b146100c85780639c475207146100c3578063c751fbfb146100be578063de523cf3146100b9578063e53091b7146100b4578063e81900a6146100af5763f2fde38b146100aa57600080fd5b6106b1565b6105e3565b610557565b610232565b610513565b6104dc565b6104b5565b610449565b610412565b610289565b6101f8565b610163565b634e487b7160e01b600052604160045260246000fd5b604051906040820182811067ffffffffffffffff82111761011c57604052565b6100e6565b6040519190601f01601f1916820167ffffffffffffffff81118382101761011c57604052565b67ffffffffffffffff811161011c57601f01601f191660200190565b346101f35760003660031901126101f35761017c6100fc565b6009815260207f68797065726c616e650000000000000000000000000000000000000000000000818301526040908151928184928352815191828285015260005b8381106101dd575050600083830185015250601f01601f19168101030190f35b81810183015187820187015286945082016101bd565b600080fd5b346101f35760403660031901126101f357600435600052600060205260406000206024356000526020526020604060002054604051908152f35b346101f35760003660031901126101f35760206040516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b6004359063ffffffff821682036101f357565b60603660031901126101f35761029d610276565b60443567ffffffffffffffff8082116101f357366023830112156101f35781600401358181116101f35782019060248201903682116101f3576001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001633148015906103f2575b6103c85763ffffffff60009516855260209160038352604085818820549503126103ad5760248501358281116103c457850192816043850112156103c45760248401359361035f61035a866105cb565b610121565b9460448387838152019160051b830101918483116103c057604401905b8282106103b1575050505060448501359182116103ad5760246103a4926103aa960101610aac565b91610b02565b80f35b8580fd5b8135815290830190830161037c565b8980fd5b8680fd5b60046040517ff920c49e000000000000000000000000000000000000000000000000000000008152fd5b5063ffffffff85166000526002602052602435604060002054141561030a565b346101f35760203660031901126101f35763ffffffff610430610276565b1660005260036020526020604060002054604051908152f35b346101f3576000806003193601126104b257610463610756565b806001600160a01b0360015473ffffffffffffffffffffffffffffffffffffffff198116600155167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b346101f35760003660031901126101f35760206001600160a01b0360015416604051908152f35b346101f35760203660031901126101f35763ffffffff6104fa610276565b1660005260026020526020604060002054604051908152f35b346101f35760003660031901126101f35760206040516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168152f35b346101f35760603660031901126101f35760043560243563ffffffff81168091036101f35760443590610588610756565b600092818452600260205282604085205560036020528060408520557f33650c025ba183d07fb1e4533c7f06438835fff96b46d07d6112ed2dda6149ba8480a480f35b67ffffffffffffffff811161011c5760051b60200190565b346101f35760403660031901126101f357602467ffffffffffffffff81358181116101f357366023820112156101f35780600401359261062561035a856105cb565b9384938186528260208097019260051b850101933685116101f357838101925b85841061065a57610658876004356108c5565b005b83358381116101f357820190366043830112156101f357858201359061068261035a83610147565b828152604493368585830101116101f3578b848196958296600094018386013783010152815201930192610645565b346101f35760203660031901126101f3576004356001600160a01b0381168082036101f3576106de610756565b156106ec57610658906107ae565b608460405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b6001600160a01b0360015416330361076a57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b600154906001600160a01b03809116918273ffffffffffffffffffffffffffffffffffffffff19821617600155167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3565b634e487b7160e01b600052601160045260246000fd5b60001981146108285760010190565b610803565b634e487b7160e01b600052603260045260246000fd5b8051156108505760200190565b61082d565b805160081015610850576101200190565b80518210156108505760209160051b010190565b60001981019190821161082857565b60bf1981019190821161082857565b607f1981019190821161082857565b60f61981019190821161082857565b60b61981019190821161082857565b91909160005b8351811015610a3e576108e76108e18286610866565b51610b57565b6108f76108f382610c65565b1590565b610a145761090490610b9c565b8051600f81108015610a0a575b6109d7575061093461092861092e61092884610843565b51610c8c565b92610855565b61093e8387610866565b516020815191012061096d8261095e876000526000602052604060002090565b90600052602052604060002090565b54808203610998575050610993929161098861098e9261087a565b85610a44565b610819565b6108cb565b6040517fc442fd2b0000000000000000000000000000000000000000000000000000000081526004810184905260248101929092526044820152606490fd5b6040517f9fd6e11c0000000000000000000000000000000000000000000000000000000081526004810191909152602490fd5b5060118111610911565b60046040517fe4508b9f000000000000000000000000000000000000000000000000000000008152fd5b50509050565b6000818152806020526040812083825260205283604082205403610a69575b50505050565b7f7c57815e36323391c63e53a2fe2969599eb6dbcf52484a3bd8909aef4a6704d7918152806020526040812083825260205283604082205580a338808080610a63565b9080601f830112156101f357813590610ac761035a836105cb565b9182938184526020808095019260051b8201019283116101f3578301905b828210610af3575050505090565b81358152908301908301610ae5565b92919060005b8151811015610b3a5780610b34610b2160019385610866565b51610b2c8387610866565b519088610a44565b01610b08565b5050509050565b610b496100fc565b906000825260006020830152565b60006020610b636100fc565b82815201526020815191610b756100fc565b92835201602082015290565b906001820180921161082857565b9190820180921161082857565b610ba581610c65565b156101f357610bb381610ceb565b610bbf61035a826105cb565b81815291601f19610bcf836105cb565b0160005b818110610c4e575050610bf4602080920151610bee81610dd4565b90610b8f565b6000905b838210610c06575050505090565b610c4281610c16610c4893610d4d565b90610c1f6100fc565b8281528187820152610c31868a610866565b52610c3c8589610866565b50610b8f565b91610819565b90610bf8565b602090610c59610b41565b82828801015201610bd3565b805115610c8657602060c09101515160001a10610c8157600190565b600090565b50600090565b80518015159081610cdf575b50156101f3576020810190610cad8251610dd4565b915190828201809211610828575191820391821161082857519060208110610cd3575090565b6020036101000a900490565b60219150111538610c98565b805115610c865760009060208101908151610d0581610dd4565b8101809111610828579151905181018091116108285791905b828110610d2b5750905090565b610d3481610d4d565b810180911161082857610d479091610819565b90610d1e565b805160001a906080821015610d6457505060015b90565b60b8821015610d7f5750610d7a610d6191610898565b610b81565b9060c0811015610da35760b51991600160b783602003016101000a91015104010190565b9060f8821015610dba5750610d7a610d6191610889565b60010151602082900360f7016101000a90040160f5190190565b5160001a6080811015610de75750600090565b60b881108015610e1e575b15610dfd5750600190565b60c0811015610e1257610d7a610d61916108b6565b610d7a610d61916108a7565b5060c08110158015610df2575060f88110610df256fea2646970667358221220ca283ed9ff50b4d52fdc9b1bb2f3681376274dad35a97cdbd72f60c0c70171df64736f6c63430008140033",
  "devdoc": {
    "events": {
      "HashStored(uint256,bytes32)": {
        "details": "Emitted when a hash is stored.",
        "params": {
          "hash": "- The stored hash as bytes32 values.",
          "id": "- The ID of the stored hash."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "getHash(uint256,uint256)": {
        "details": "Returns the hash for a given ID.",
        "params": {
          "domain": "- Identifier for the domain to query.",
          "id": "- Identifier for the ID to query."
        },
        "returns": {
          "_0": "Bytes32 hash for the given ID on the given domain."
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "proveAncestralBlockHashes(uint256,bytes[])": {
        "details": "Proves and stores valid ancestral block hashes for a given chain ID.",
        "params": {
          "blockHeaders": "- The RLP encoded block headers to prove the hashes for.",
          "chainId": "- The ID of the chain to prove block hashes for."
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getHash(uint256,uint256)": {
        "notice": "MUST return bytes32(0) if the hash is not present."
      },
      "proveAncestralBlockHashes(uint256,bytes[])": {
        "notice": "Block headers should be ordered by descending block number and should start with a known block header."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 193,
        "contract": "contracts/adapeters/Hyperlane/HyperlaneAdapter.sol:HyperlaneAdapter",
        "label": "_hashes",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_mapping(t_uint256,t_bytes32))"
      },
      {
        "astId": 54,
        "contract": "contracts/adapeters/Hyperlane/HyperlaneAdapter.sol:HyperlaneAdapter",
        "label": "_owner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 454,
        "contract": "contracts/adapeters/Hyperlane/HyperlaneAdapter.sol:HyperlaneAdapter",
        "label": "enabledReporters",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint32,t_bytes32)"
      },
      {
        "astId": 458,
        "contract": "contracts/adapeters/Hyperlane/HyperlaneAdapter.sol:HyperlaneAdapter",
        "label": "chainIds",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint32,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_uint256,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint256,t_mapping(t_uint256,t_bytes32))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(uint256 => bytes32))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_bytes32)"
      },
      "t_mapping(t_uint32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  }
}