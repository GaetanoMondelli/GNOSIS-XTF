{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/MerklePatriciaProofVerifier.sol": {
      "content": "pragma solidity ^0.8.20;\n/* solhint-disable */\n\nimport { RLPReader } from \"solidity-rlp/contracts/RLPReader.sol\";\n\nlibrary MerklePatriciaProofVerifier {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    /// @dev Validates a Merkle-Patricia-Trie proof.\n    ///      If the proof proves the inclusion of some key-value pair in the\n    ///      trie, the value is returned. Otherwise, i.e. if the proof proves\n    ///      the exclusion of a key from the trie, an empty byte array is\n    ///      returned.\n    /// @param rootHash is the Keccak-256 hash of the root node of the MPT.\n    /// @param path is the key of the node whose inclusion/exclusion we are\n    ///        proving.\n    /// @param stack is the stack of MPT nodes (starting with the root) that\n    ///        need to be traversed during verification.\n    /// @return value whose inclusion is proved or an empty byte array for\n    ///         a proof of exclusion\n    function extractProofValue(\n        bytes32 rootHash,\n        bytes memory path,\n        RLPReader.RLPItem[] memory stack\n    ) internal pure returns (bytes memory value) {\n        bytes memory mptKey = _decodeNibbles(path, 0);\n        uint256 mptKeyOffset = 0;\n\n        bytes32 nodeHashHash;\n        RLPReader.RLPItem[] memory node;\n\n        RLPReader.RLPItem memory rlpValue;\n\n        if (stack.length == 0) {\n            // Root hash of empty Merkle-Patricia-Trie\n            require(rootHash == 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421);\n            return new bytes(0);\n        }\n\n        // Traverse stack of nodes starting at root.\n        for (uint256 i = 0; i < stack.length; i++) {\n            // We use the fact that an rlp encoded list consists of some\n            // encoding of its length plus the concatenation of its\n            // *rlp-encoded* items.\n\n            // The root node is hashed with Keccak-256 ...\n            if (i == 0 && rootHash != stack[i].rlpBytesKeccak256()) {\n                revert();\n            }\n            // ... whereas all other nodes are hashed with the MPT\n            // hash function.\n            if (i != 0 && nodeHashHash != _mptHashHash(stack[i])) {\n                revert();\n            }\n            // We verified that stack[i] has the correct hash, so we\n            // may safely decode it.\n            node = stack[i].toList();\n\n            if (node.length == 2) {\n                // Extension or Leaf node\n\n                bool isLeaf;\n                bytes memory nodeKey;\n                (isLeaf, nodeKey) = _merklePatriciaCompactDecode(node[0].toBytes());\n\n                uint256 prefixLength = _sharedPrefixLength(mptKeyOffset, mptKey, nodeKey);\n                mptKeyOffset += prefixLength;\n\n                if (prefixLength < nodeKey.length) {\n                    // Proof claims divergent extension or leaf. (Only\n                    // relevant for proofs of exclusion.)\n                    // An Extension/Leaf node is divergent iff it 'skips' over\n                    // the point at which a Branch node should have been had the\n                    // excluded key been included in the trie.\n                    // Example: Imagine a proof of exclusion for path [1, 4],\n                    // where the current node is a Leaf node with\n                    // path [1, 3, 3, 7]. For [1, 4] to be included, there\n                    // should have been a Branch node at [1] with a child\n                    // at 3 and a child at 4.\n\n                    // Sanity check\n                    if (i < stack.length - 1) {\n                        // divergent node must come last in proof\n                        revert();\n                    }\n\n                    return new bytes(0);\n                }\n\n                if (isLeaf) {\n                    // Sanity check\n                    if (i < stack.length - 1) {\n                        // leaf node must come last in proof\n                        revert();\n                    }\n\n                    if (mptKeyOffset < mptKey.length) {\n                        return new bytes(0);\n                    }\n\n                    rlpValue = node[1];\n                    return rlpValue.toBytes();\n                } else {\n                    // extension\n                    // Sanity check\n                    if (i == stack.length - 1) {\n                        // shouldn't be at last level\n                        revert();\n                    }\n\n                    if (!node[1].isList()) {\n                        // rlp(child) was at least 32 bytes. node[1] contains\n                        // Keccak256(rlp(child)).\n                        nodeHashHash = node[1].payloadKeccak256();\n                    } else {\n                        // rlp(child) was less than 32 bytes. node[1] contains\n                        // rlp(child).\n                        nodeHashHash = node[1].rlpBytesKeccak256();\n                    }\n                }\n            } else if (node.length == 17) {\n                // Branch node\n\n                if (mptKeyOffset != mptKey.length) {\n                    // we haven't consumed the entire path, so we need to look at a child\n                    uint8 nibble = uint8(mptKey[mptKeyOffset]);\n                    mptKeyOffset += 1;\n                    if (nibble >= 16) {\n                        // each element of the path has to be a nibble\n                        revert();\n                    }\n\n                    if (_isEmptyBytesequence(node[nibble])) {\n                        // Sanity\n                        if (i != stack.length - 1) {\n                            // leaf node should be at last level\n                            revert();\n                        }\n\n                        return new bytes(0);\n                    } else if (!node[nibble].isList()) {\n                        nodeHashHash = node[nibble].payloadKeccak256();\n                    } else {\n                        nodeHashHash = node[nibble].rlpBytesKeccak256();\n                    }\n                } else {\n                    // we have consumed the entire mptKey, so we need to look at what's contained in this node.\n\n                    // Sanity\n                    if (i != stack.length - 1) {\n                        // should be at last level\n                        revert();\n                    }\n\n                    return node[16].toBytes();\n                }\n            }\n        }\n    }\n\n    /// @dev Computes the hash of the Merkle-Patricia-Trie hash of the RLP item.\n    ///      Merkle-Patricia-Tries use a weird 'hash function' that outputs\n    ///      *variable-length* hashes: If the item is shorter than 32 bytes,\n    ///      the MPT hash is the item. Otherwise, the MPT hash is the\n    ///      Keccak-256 hash of the item.\n    ///      The easiest way to compare variable-length byte sequences is\n    ///      to compare their Keccak-256 hashes.\n    /// @param item The RLP item to be hashed.\n    /// @return Keccak-256(MPT-hash(item))\n    function _mptHashHash(RLPReader.RLPItem memory item) private pure returns (bytes32) {\n        if (item.len < 32) {\n            return item.rlpBytesKeccak256();\n        } else {\n            return keccak256(abi.encodePacked(item.rlpBytesKeccak256()));\n        }\n    }\n\n    function _isEmptyBytesequence(RLPReader.RLPItem memory item) private pure returns (bool) {\n        if (item.len != 1) {\n            return false;\n        }\n        uint8 b;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            b := byte(0, mload(memPtr))\n        }\n        return b == 0x80; /* empty byte string */\n    }\n\n    function _merklePatriciaCompactDecode(\n        bytes memory compact\n    ) private pure returns (bool isLeaf, bytes memory nibbles) {\n        require(compact.length > 0);\n        uint256 first_nibble = (uint8(compact[0]) >> 4) & 0xF;\n        uint256 skipNibbles;\n        if (first_nibble == 0) {\n            skipNibbles = 2;\n            isLeaf = false;\n        } else if (first_nibble == 1) {\n            skipNibbles = 1;\n            isLeaf = false;\n        } else if (first_nibble == 2) {\n            skipNibbles = 2;\n            isLeaf = true;\n        } else if (first_nibble == 3) {\n            skipNibbles = 1;\n            isLeaf = true;\n        } else {\n            // Not supposed to happen!\n            revert();\n        }\n        return (isLeaf, _decodeNibbles(compact, skipNibbles));\n    }\n\n    function _decodeNibbles(bytes memory compact, uint256 skipNibbles) private pure returns (bytes memory nibbles) {\n        require(compact.length > 0);\n\n        uint256 length = compact.length * 2;\n        require(skipNibbles <= length);\n        length -= skipNibbles;\n\n        nibbles = new bytes(length);\n        uint256 nibblesLength = 0;\n\n        for (uint256 i = skipNibbles; i < skipNibbles + length; i += 1) {\n            if (i % 2 == 0) {\n                nibbles[nibblesLength] = bytes1((uint8(compact[i / 2]) >> 4) & 0xF);\n            } else {\n                nibbles[nibblesLength] = bytes1((uint8(compact[i / 2]) >> 0) & 0xF);\n            }\n            nibblesLength += 1;\n        }\n\n        assert(nibblesLength == nibbles.length);\n    }\n\n    function _sharedPrefixLength(uint256 xsOffset, bytes memory xs, bytes memory ys) private pure returns (uint256) {\n        uint256 i;\n        for (i = 0; i + xsOffset < xs.length && i < ys.length; i++) {\n            if (xs[i + xsOffset] != ys[i]) {\n                return i;\n            }\n        }\n        return i;\n    }\n}"
    },
    "contracts/Prover.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { RLPReader } from \"solidity-rlp/contracts/RLPReader.sol\";\nimport { MerklePatriciaProofVerifier } from \".//MerklePatriciaProofVerifier.sol\";\n\ninterface IGiriGiriBashi {\n\tfunction getThresholdHash(\n\t\tuint256 domain,\n\t\tuint256 id\n\t) external view returns (bytes32);\n}\n\ninterface IProver {\n\terror InvalidLatestCommitment(\n\t\tbytes32 latestCommitment,\n\t\tbytes32 expectedLatestCommitment\n\t);\n\terror InvalidBlockHeader(\n\t\tbytes32 blockHeaderHash,\n\t\tbytes32 expectedBlockHeaderHash\n\t);\n\terror InvalidAccountStorageRoot();\n\terror InvalidNonce(uint256 nonce, uint256 expectedNonce);\n\terror InvalidAccountRlp(bytes accountRlp);\n\n\tstruct Proof {\n\t\tuint256 blockNumber;\n\t\tuint256 nonce;\n\t\t// bytes blockHeader;\n\t\tbytes32 storageRoot;\n\t\t// bytes accountProof;\n\t\tbytes storageProof;\n\t}\n\n\tfunction setAccount(address account) external;\n}\n\ncontract Prover is IProver {\n\tusing RLPReader for RLPReader.RLPItem;\n\tusing RLPReader for bytes;\n\n\tuint256 public immutable SOURCE_CHAIN_ID;\n\tuint256 public immutable COMMITMENTS_SLOT;\n\taddress public ACCOUNT;\n\taddress public immutable GIRI_GIRI_BASHI;\n\n\tuint256 public expectedNonce;\n\n\tconstructor(\n\t\tuint256 sourceChainId,\n\t\tuint256 commitmentsSlot,\n\t\taddress giriGiriBashi\n\t) {\n\t\tSOURCE_CHAIN_ID = sourceChainId;\n\t\tCOMMITMENTS_SLOT = commitmentsSlot;\n\t\tGIRI_GIRI_BASHI = giriGiriBashi;\n\t}\n\n\t// @inheritdoc IProver\n\tfunction setAccount(address account) external {\n\t\tACCOUNT = account;\n\t}\n\n\tfunction _verifyProof(\n\t\tProof calldata proof,\n\t\tbytes memory data\n\t) public returns (bool) {\n\t\t// bytes32 expectedBlockHeaderHash = IGiriGiriBashi(GIRI_GIRI_BASHI)\n\t\t// \t.getThresholdHash(SOURCE_CHAIN_ID, proof.blockNumber);\n\t\t// bytes32 blockHeaderHash = keccak256(proof.blockHeader);\n\t\t// if (expectedBlockHeaderHash != blockHeaderHash)\n\t\t// \trevert InvalidBlockHeader(blockHeaderHash, expectedBlockHeaderHash);\n\n\t\t// bytes32 expectedLatestCommitment = _verifyStorageProofAndGetValue(\n\t\t// \t_verifyAccountProofAndGetStorageRoot(\n\t\t// \t\tproof.blockHeader,\n\t\t// \t\tproof.accountProof\n\t\t// \t),\n\t\t// \tproof.storageProof\n\t\t// );\n\t\tbytes32 expectedLatestCommitment = _verifyStorageProofAndGetValue(\n\t\t\tproof.storageRoot,\n\t\t\tproof.storageProof\n\t\t);\n\t\tbytes32 latestCommitment = keccak256(\n\t\t\tabi.encode(block.chainid, data, proof.nonce)\n\t\t);\n\t\tif (expectedLatestCommitment != latestCommitment) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// _checkNonceAndIncrementExpectedNonce(proof.nonce);\n\t\treturn true;\n\t}\n\n\t// function _verifyAccountProofAndGetStorageRoot(\n\t// \tbytes memory blockHeader,\n\t// \tbytes memory accountProof\n\t// ) internal view returns (bytes32) {\n\t// \tRLPReader.RLPItem[] memory blockHeaderFields = blockHeader\n\t// \t\t.toRlpItem()\n\t// \t\t.toList();\n\t// \tbytes32 stateRoot = bytes32(blockHeaderFields[3].toUint());\n\t// \tbytes memory accountRlp = MerklePatriciaProofVerifier.extractProofValue(\n\t// \t\tstateRoot,\n\t// \t\tabi.encodePacked(keccak256(abi.encodePacked(ACCOUNT))),\n\t// \t\taccountProof.toRlpItem().toList()\n\t// \t);\n\t// \tbytes32 accountStorageRoot = bytes32(\n\t// \t\taccountRlp.toRlpItem().toList()[2].toUint()\n\t// \t);\n\t// \tif (accountStorageRoot.length == 0) revert InvalidAccountStorageRoot();\n\t// \tRLPReader.RLPItem[] memory accountFields = accountRlp\n\t// \t\t.toRlpItem()\n\t// \t\t.toList();\n\t// \tif (accountFields.length != 4) revert InvalidAccountRlp(accountRlp); // [nonce, balance, storageRoot, codeHash]\n\t// \treturn bytes32(accountFields[2].toUint());\n\t// }\n\n\tfunction _verifyStorageProofAndGetValue(\n\t\tbytes32 storageRoot,\n\t\tbytes calldata storageProof\n\t) internal view returns (bytes32) {\n\t\t// bytes memory slotValue = MerklePatriciaProofVerifier.extractProofValue(\n\t\t// \tstorageRoot,\n\t\t// \t// abi.encodePacked(\n\t\t// \t// \tkeccak256(\n\t\t// \t// \t\tabi.encode(\n\t\t// \t// \t\t\tkeccak256(abi.encode(msg.sender, COMMITMENTS_SLOT))\n\t\t// \t// \t\t)\n\t\t// \t// \t)\n\t\t// \t// ),\n\t\t// \tabi.encodePacked(bytes32(uint256(0))),\n\t\t// \tstorageProof.toRlpItem().toList()\n\t\t// );\n\t\treturn _bytesToBytes32(\"42\");\n\t}\n\n\tfunction _checkNonceAndIncrementExpectedNonce(uint256 nonce) internal {\n\t\tif (nonce != expectedNonce) revert InvalidNonce(nonce, expectedNonce);\n\t\tunchecked {\n\t\t\t++expectedNonce;\n\t\t}\n\t}\n\n\tfunction _bytesToBytes32(\n\t\tbytes memory source\n\t) internal pure returns (bytes32 result) {\n\t\tif (source.length == 0) {\n\t\t\treturn bytes32(0);\n\t\t}\n\t\t// solhint-disable-next-line\n\t\tassembly {\n\t\t\tresult := mload(add(add(source, 1), 32))\n\t\t}\n\t}\n}\n"
    },
    "solidity-rlp/contracts/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\npragma solidity >=0.5.10 <0.9.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        (, uint256 len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n     * @param the RLP item containing the encoded list.\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n        uint256 result;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}