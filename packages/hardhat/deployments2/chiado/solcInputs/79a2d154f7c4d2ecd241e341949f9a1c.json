{
  "language": "Solidity",
  "sources": {
    "@hyperlane-xyz/core/contracts/interfaces/hooks/IPostDispatchHook.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.0;\n\n/*@@@@@@@       @@@@@@@@@\n @@@@@@@@@       @@@@@@@@@\n  @@@@@@@@@       @@@@@@@@@\n   @@@@@@@@@       @@@@@@@@@\n    @@@@@@@@@@@@@@@@@@@@@@@@@\n     @@@@@  HYPERLANE  @@@@@@@\n    @@@@@@@@@@@@@@@@@@@@@@@@@\n   @@@@@@@@@       @@@@@@@@@\n  @@@@@@@@@       @@@@@@@@@\n @@@@@@@@@       @@@@@@@@@\n@@@@@@@@@       @@@@@@@@*/\n\ninterface IPostDispatchHook {\n    enum Types {\n        UNUSED,\n        ROUTING,\n        AGGREGATION,\n        MERKLE_TREE,\n        INTERCHAIN_GAS_PAYMASTER,\n        FALLBACK_ROUTING,\n        ID_AUTH_ISM,\n        PAUSABLE,\n        PROTOCOL_FEE,\n        LAYER_ZERO_V1\n    }\n\n    /**\n     * @notice Returns an enum that represents the type of hook\n     */\n    function hookType() external view returns (uint8);\n\n    /**\n     * @notice Returns whether the hook supports metadata\n     * @param metadata metadata\n     * @return Whether the hook supports metadata\n     */\n    function supportsMetadata(\n        bytes calldata metadata\n    ) external view returns (bool);\n\n    /**\n     * @notice Post action after a message is dispatched via the Mailbox\n     * @param metadata The metadata required for the hook\n     * @param message The message passed from the Mailbox.dispatch() call\n     */\n    function postDispatch(\n        bytes calldata metadata,\n        bytes calldata message\n    ) external payable;\n\n    /**\n     * @notice Compute the payment required by the postDispatch call\n     * @param metadata The metadata required for the hook\n     * @param message The message passed from the Mailbox.dispatch() call\n     * @return Quoted payment for the postDispatch call\n     */\n    function quoteDispatch(\n        bytes calldata metadata,\n        bytes calldata message\n    ) external view returns (uint256);\n}\n"
    },
    "@hyperlane-xyz/core/contracts/interfaces/IInterchainSecurityModule.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\ninterface IInterchainSecurityModule {\n    enum Types {\n        UNUSED,\n        ROUTING,\n        AGGREGATION,\n        LEGACY_MULTISIG,\n        MERKLE_ROOT_MULTISIG,\n        MESSAGE_ID_MULTISIG,\n        NULL, // used with relayer carrying no metadata\n        CCIP_READ\n    }\n\n    /**\n     * @notice Returns an enum that represents the type of security model\n     * encoded by this ISM.\n     * @dev Relayers infer how to fetch and format metadata.\n     */\n    function moduleType() external view returns (uint8);\n\n    /**\n     * @notice Defines a security model responsible for verifying interchain\n     * messages based on the provided metadata.\n     * @param _metadata Off-chain metadata provided by a relayer, specific to\n     * the security model encoded by the module (e.g. validator signatures)\n     * @param _message Hyperlane encoded interchain message\n     * @return True if the message was verified\n     */\n    function verify(\n        bytes calldata _metadata,\n        bytes calldata _message\n    ) external returns (bool);\n}\n\ninterface ISpecifiesInterchainSecurityModule {\n    function interchainSecurityModule()\n        external\n        view\n        returns (IInterchainSecurityModule);\n}\n"
    },
    "@hyperlane-xyz/core/contracts/interfaces/IMailbox.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.0;\n\nimport {IInterchainSecurityModule} from \"./IInterchainSecurityModule.sol\";\nimport {IPostDispatchHook} from \"./hooks/IPostDispatchHook.sol\";\n\ninterface IMailbox {\n    // ============ Events ============\n    /**\n     * @notice Emitted when a new message is dispatched via Hyperlane\n     * @param sender The address that dispatched the message\n     * @param destination The destination domain of the message\n     * @param recipient The message recipient address on `destination`\n     * @param message Raw bytes of message\n     */\n    event Dispatch(\n        address indexed sender,\n        uint32 indexed destination,\n        bytes32 indexed recipient,\n        bytes message\n    );\n\n    /**\n     * @notice Emitted when a new message is dispatched via Hyperlane\n     * @param messageId The unique message identifier\n     */\n    event DispatchId(bytes32 indexed messageId);\n\n    /**\n     * @notice Emitted when a Hyperlane message is processed\n     * @param messageId The unique message identifier\n     */\n    event ProcessId(bytes32 indexed messageId);\n\n    /**\n     * @notice Emitted when a Hyperlane message is delivered\n     * @param origin The origin domain of the message\n     * @param sender The message sender address on `origin`\n     * @param recipient The address that handled the message\n     */\n    event Process(\n        uint32 indexed origin,\n        bytes32 indexed sender,\n        address indexed recipient\n    );\n\n    function localDomain() external view returns (uint32);\n\n    function delivered(bytes32 messageId) external view returns (bool);\n\n    function defaultIsm() external view returns (IInterchainSecurityModule);\n\n    function defaultHook() external view returns (IPostDispatchHook);\n\n    function requiredHook() external view returns (IPostDispatchHook);\n\n    function latestDispatchedId() external view returns (bytes32);\n\n    function dispatch(\n        uint32 destinationDomain,\n        bytes32 recipientAddress,\n        bytes calldata messageBody\n    ) external payable returns (bytes32 messageId);\n\n    function quoteDispatch(\n        uint32 destinationDomain,\n        bytes32 recipientAddress,\n        bytes calldata messageBody\n    ) external view returns (uint256 fee);\n\n    function dispatch(\n        uint32 destinationDomain,\n        bytes32 recipientAddress,\n        bytes calldata body,\n        bytes calldata defaultHookMetadata\n    ) external payable returns (bytes32 messageId);\n\n    function quoteDispatch(\n        uint32 destinationDomain,\n        bytes32 recipientAddress,\n        bytes calldata messageBody,\n        bytes calldata defaultHookMetadata\n    ) external view returns (uint256 fee);\n\n    function dispatch(\n        uint32 destinationDomain,\n        bytes32 recipientAddress,\n        bytes calldata body,\n        bytes calldata customHookMetadata,\n        IPostDispatchHook customHook\n    ) external payable returns (bytes32 messageId);\n\n    function quoteDispatch(\n        uint32 destinationDomain,\n        bytes32 recipientAddress,\n        bytes calldata messageBody,\n        bytes calldata customHookMetadata,\n        IPostDispatchHook customHook\n    ) external view returns (uint256 fee);\n\n    function process(\n        bytes calldata metadata,\n        bytes calldata message\n    ) external payable;\n\n    function recipientIsm(\n        address recipient\n    ) external view returns (IInterchainSecurityModule module);\n}\n"
    },
    "@hyperlane-xyz/core/contracts/libs/TypeCasts.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/adapeters/Hyperlane/HyperlaneReporter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IMailbox } from \"@hyperlane-xyz/core/contracts/interfaces/IMailbox.sol\";\nimport { TypeCasts } from \"@hyperlane-xyz/core/contracts/libs/TypeCasts.sol\";\nimport { Reporter } from \"../Reporter.sol\";\n\ncontract HyperlaneReporter is Reporter, Ownable {\n    using TypeCasts for address;\n\n    string public constant PROVIDER = \"hyperlane\";\n    IMailbox public immutable HYPERLANE_MAILBOX;\n\n    mapping(uint256 => uint32) public domains;\n\n    error DomainNotAvailable();\n\n    event DomainSet(uint256 indexed chainId, uint32 indexed domain);\n\n    constructor(address headerStorage, address yaho, address hyperlaneMailbox) Reporter(headerStorage, yaho) {\n        HYPERLANE_MAILBOX = IMailbox(hyperlaneMailbox);\n    }\n\n    function setDomainByChainId(uint256 chainId, uint32 domain) external onlyOwner {\n        domains[chainId] = domain;\n        emit DomainSet(chainId, domain);\n    }\n\n    function _dispatch(\n        uint256 targetChainId,\n        address adapter,\n        uint256[] memory ids,\n        bytes32[] memory hashes\n    ) internal override returns (bytes32) {\n        uint32 targetDomain = domains[targetChainId];\n        if (targetDomain == 0) revert DomainNotAvailable();\n        bytes memory payload = abi.encode(ids, hashes);\n        \t\tuint256 fee = HYPERLANE_MAILBOX.quoteDispatch(\n\t\t\ttargetDomain, adapter.addressToBytes32(), payload\n\t\t);\n        if (fee > msg.value) revert(\"Insufficient fee\");\n        HYPERLANE_MAILBOX.dispatch{ value: fee }(targetDomain, adapter.addressToBytes32(), payload);\n\n        return bytes32(0);\n    }\n}\n"
    },
    "contracts/adapeters/Mock/MockReporter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.20;\n\nimport { Reporter } from \"../Reporter.sol\";\nimport { IAdapter } from \"../../interfaces/IAdapter.sol\";\n\ncontract MockReporter is Reporter {\n    constructor(address headerStorage, address yaho) Reporter(headerStorage, yaho) {}\n\n    function _dispatch(uint256, address, uint256[] memory, bytes32[] memory) internal override returns (bytes32) {}\n}\n"
    },
    "contracts/adapeters/Reporter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.20;\n\nimport { IHeaderStorage } from \"../interfaces/IHeaderStorage.sol\";\nimport { IReporter } from \"../interfaces/IReporter.sol\";\nimport { IAdapter } from \"../interfaces/IAdapter.sol\";\n\nabstract contract Reporter is IReporter {\n    address public immutable HEADER_STORAGE;\n    address public immutable YAHO;\n\n    modifier onlyYaho() {\n        if (msg.sender != YAHO) revert NotYaho(msg.sender, YAHO);\n        _;\n    }\n\n    constructor(address headerStorage, address yaho) {\n        HEADER_STORAGE = headerStorage;\n        YAHO = yaho;\n    }\n\n    /// @inheritdoc IReporter\n    function dispatchBlocks(\n        uint256 targetChainId,\n        IAdapter adapter,\n        uint256[] memory blockNumbers\n    ) external payable returns (bytes32) {\n        bytes32[] memory blockHeaders = IHeaderStorage(HEADER_STORAGE).storeBlockHeaders(blockNumbers);\n        for (uint256 i = 0; i < blockNumbers.length; ) {\n            emit BlockDispatched(targetChainId, adapter, blockNumbers[i], blockHeaders[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return _dispatch(targetChainId, address(adapter), blockNumbers, blockHeaders);\n    }\n\n    /// @inheritdoc IReporter\n    function dispatchMessages(\n        uint256 targetChainId,\n        IAdapter adapter,\n        uint256[] memory messageIds,\n        bytes32[] memory messageHashes\n    ) external payable onlyYaho returns (bytes32) {\n        for (uint256 i = 0; i < messageIds.length; ) {\n            emit MessageDispatched(targetChainId, adapter, messageIds[i], messageHashes[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return _dispatch(targetChainId, address(adapter), messageIds, messageHashes);\n    }\n\n    function _dispatch(\n        uint256 targetChainId,\n        address adapter,\n        uint256[] memory messageIds,\n        bytes32[] memory messageHashes\n    ) internal virtual returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IAdapter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title IAdapter\n */\ninterface IAdapter {\n    error ConflictingBlockHeader(uint256 blockNumber, bytes32 blockHash, bytes32 storedBlockHash);\n    error InvalidBlockHeaderLength(uint256 length);\n    error InvalidBlockHeaderRLP();\n\n    /**\n     * @dev Emitted when a hash is stored.\n     * @param id - The ID of the stored hash.\n     * @param hash - The stored hash as bytes32 values.\n     */\n    event HashStored(uint256 indexed id, bytes32 indexed hash);\n\n    /**\n     * @dev Returns the hash for a given ID.\n     * @param domain - Identifier for the domain to query.\n     * @param id - Identifier for the ID to query.\n     * @return hash Bytes32 hash for the given ID on the given domain.\n     * @notice MUST return bytes32(0) if the hash is not present.\n     */\n    function getHash(uint256 domain, uint256 id) external view returns (bytes32 hash);\n}\n"
    },
    "contracts/interfaces/IHeaderStorage.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.0;\n\n/**\n * @title IHeaderStorage\n */\ninterface IHeaderStorage {\n    error HeaderOutOfRange(uint256 blockNumber);\n\n    /**\n     * @dev Emitted when a block header is stored.\n     * @param blockNumber - The block number associated with the stored header.\n     * @param blockHeader - The stored block header as a bytes32 value.\n     */\n    event HeaderStored(uint256 indexed blockNumber, bytes32 indexed blockHeader);\n\n    /**\n     * @dev Retrieves the stored block header for a specific block number.\n     * @param blockNumber - The block number as a uint256 value.\n     * @return The block header as a bytes32 value.\n     */\n    function headers(uint256 blockNumber) external view returns (bytes32);\n\n    /**\n     * @dev Stores and returns the header for the given block.\n     * @param blockNumber - Block number.\n     * @return blockHeader - Block header stored.\n     * @notice Reverts if the given block header was not previously stored and is now out of range.\n     */\n    function storeBlockHeader(uint256 blockNumber) external returns (bytes32);\n\n    /**\n     * @dev Stores and returns the header for an array of given blocks.\n     * @param blockNumbers - Array of block numbers.\n     * @return blockHeaders - Array of block headers stored.\n     * @notice Reverts if the given block header was not previously stored and is now out of range.\n     */\n    function storeBlockHeaders(uint256[] memory blockNumbers) external returns (bytes32[] memory);\n}\n"
    },
    "contracts/interfaces/IReporter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport { IAdapter } from \"./IAdapter.sol\";\n\ninterface IReporter {\n    error NotYaho(address sender, address expectedYaho);\n\n    /**\n     * @dev Emitted when a block is dispatched to another chain.\n     * @param targetChainId - The target chain's identifier associated with the dispatched block.\n     * @param adapter - The adapter address associated with the dispatched block.\n     * @param blockNumber - The block number associated with the dispatched block.\n     * @param blockHeader - The dispatched block header as a bytes32 value.\n     */\n    event BlockDispatched(\n        uint256 indexed targetChainId,\n        IAdapter adapter,\n        uint256 indexed blockNumber,\n        bytes32 blockHeader\n    );\n\n    /**\n     * @dev Emitted when a message is dispatched to another chain.\n     * @param targetChainId - The target chain's identifier associated with the dispatched message.\n     * @param adapter - The adapter address associated with the dispatched message.\n     * @param messageId - The message identifier associated with the dispatched message.\n     * @param messageHash - The dispatched message hash as a bytes32 value.\n     */\n    event MessageDispatched(\n        uint256 indexed targetChainId,\n        IAdapter adapter,\n        uint256 indexed messageId,\n        bytes32 messageHash\n    );\n\n    /**\n     * @dev Dispatches blocks to a given adapter on the target chaib.\n     * @param targetChainId - The target chain's Uint256 identifier.\n     * @param adapter - The adapter instance to use.\n     * @param blockNumbers - An array of Uint256 block numbers to dispatch.\n     * @notice blockNumbers must include block numbers that are greater than or equal to (currentBlock - 256) due to EVM limitations.\n     * @return result - The result returned by the adapter as bytes.\n     */\n    function dispatchBlocks(\n        uint256 targetChainId,\n        IAdapter adapter,\n        uint256[] memory blockNumbers\n    ) external payable returns (bytes32);\n\n    /**\n     * @dev Dispatches messages to a target chain using the specified adapter.\n     * @param targetChainId - The target chain's Uint256 identifier.\n     * @param adapter - The adapter instance to use.\n     * @param messageIds - An array of Uint256 message identifiers.\n     * @param messageHashes - An array of bytes32 message hashes.\n     * @notice This function can be called only by Yaho\n     * @return result - The result returned by the adapter as bytes.\n     */\n    function dispatchMessages(\n        uint256 targetChainId,\n        IAdapter adapter,\n        uint256[] memory messageIds,\n        bytes32[] memory messageHashes\n    ) external payable returns (bytes32);\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}