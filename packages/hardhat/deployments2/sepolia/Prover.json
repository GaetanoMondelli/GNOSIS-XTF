{
  "address": "0xD92444568f9676a6D6C6e632E1B00FD48CABabDb",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "sourceChainId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "commitmentsSlot",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "giriGiriBashi",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "accountRlp",
          "type": "bytes"
        }
      ],
      "name": "InvalidAccountRlp",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidAccountStorageRoot",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "blockHeaderHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "expectedBlockHeaderHash",
          "type": "bytes32"
        }
      ],
      "name": "InvalidBlockHeader",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "latestCommitment",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "expectedLatestCommitment",
          "type": "bytes32"
        }
      ],
      "name": "InvalidLatestCommitment",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expectedNonce",
          "type": "uint256"
        }
      ],
      "name": "InvalidNonce",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ACCOUNT",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "COMMITMENTS_SLOT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "GIRI_GIRI_BASHI",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SOURCE_CHAIN_ID",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "blockNumber",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "blockHeader",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "storageRoot",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "accountProof",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "storageProof",
              "type": "bytes"
            }
          ],
          "internalType": "struct Proof",
          "name": "proof",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "_verifyProof",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "expectedNonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "setAccount",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xf39e0789362613f176771f79d2dd7f141267a2eb6215723abac6e4cd3b09a9ef",
  "receipt": {
    "to": null,
    "from": "0x2a1F5eB3e84e58e6F1e565306298B9dE1273f203",
    "contractAddress": "0xD92444568f9676a6D6C6e632E1B00FD48CABabDb",
    "transactionIndex": 115,
    "gasUsed": "1020391",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x37e7d6a4e7884832824d2d61996d77aa43863242ea840747684500849ac657d4",
    "transactionHash": "0xf39e0789362613f176771f79d2dd7f141267a2eb6215723abac6e4cd3b09a9ef",
    "logs": [],
    "blockNumber": 5740911,
    "cumulativeGasUsed": "16634641",
    "status": 1,
    "byzantium": true
  },
  "args": [
    11155111,
    "0x0",
    "0x2a1F5eB3e84e58e6F1e565306298B9dE1273f203"
  ],
  "numDeployments": 9,
  "solcInputHash": "ad45e00e8da49b1fac134c76a5a0e0ae",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sourceChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commitmentsSlot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"giriGiriBashi\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"accountRlp\",\"type\":\"bytes\"}],\"name\":\"InvalidAccountRlp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAccountStorageRoot\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"blockHeaderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expectedBlockHeaderHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidBlockHeader\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"latestCommitment\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expectedLatestCommitment\",\"type\":\"bytes32\"}],\"name\":\"InvalidLatestCommitment\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedNonce\",\"type\":\"uint256\"}],\"name\":\"InvalidNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ACCOUNT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COMMITMENTS_SLOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GIRI_GIRI_BASHI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SOURCE_CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"blockHeader\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"storageRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"accountProof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"storageProof\",\"type\":\"bytes\"}],\"internalType\":\"struct Proof\",\"name\":\"proof\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"_verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expectedNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Prover.sol\":\"Prover\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa94b34880e3c1b0b931662cb1c09e5dfa6662f31cba80e07c5ee71cd135c9673\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/MerklePatriciaProofVerifier.sol\":{\"content\":\"pragma solidity ^0.8.20;\\n/* solhint-disable */\\n\\nimport { RLPReader } from \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\n\\nlibrary MerklePatriciaProofVerifier {\\n    using RLPReader for RLPReader.RLPItem;\\n    using RLPReader for bytes;\\n\\n    /// @dev Validates a Merkle-Patricia-Trie proof.\\n    ///      If the proof proves the inclusion of some key-value pair in the\\n    ///      trie, the value is returned. Otherwise, i.e. if the proof proves\\n    ///      the exclusion of a key from the trie, an empty byte array is\\n    ///      returned.\\n    /// @param rootHash is the Keccak-256 hash of the root node of the MPT.\\n    /// @param path is the key of the node whose inclusion/exclusion we are\\n    ///        proving.\\n    /// @param stack is the stack of MPT nodes (starting with the root) that\\n    ///        need to be traversed during verification.\\n    /// @return value whose inclusion is proved or an empty byte array for\\n    ///         a proof of exclusion\\n    function extractProofValue(\\n        bytes32 rootHash,\\n        bytes memory path,\\n        RLPReader.RLPItem[] memory stack\\n    ) internal pure returns (bytes memory value) {\\n        bytes memory mptKey = _decodeNibbles(path, 0);\\n        uint256 mptKeyOffset = 0;\\n\\n        bytes32 nodeHashHash;\\n        RLPReader.RLPItem[] memory node;\\n\\n        RLPReader.RLPItem memory rlpValue;\\n\\n        if (stack.length == 0) {\\n            // Root hash of empty Merkle-Patricia-Trie\\n            require(rootHash == 0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421);\\n            return new bytes(0);\\n        }\\n\\n        // Traverse stack of nodes starting at root.\\n        for (uint256 i = 0; i < stack.length; i++) {\\n            // We use the fact that an rlp encoded list consists of some\\n            // encoding of its length plus the concatenation of its\\n            // *rlp-encoded* items.\\n\\n            // The root node is hashed with Keccak-256 ...\\n            if (i == 0 && rootHash != stack[i].rlpBytesKeccak256()) {\\n                revert();\\n            }\\n            // ... whereas all other nodes are hashed with the MPT\\n            // hash function.\\n            if (i != 0 && nodeHashHash != _mptHashHash(stack[i])) {\\n                revert();\\n            }\\n            // We verified that stack[i] has the correct hash, so we\\n            // may safely decode it.\\n            node = stack[i].toList();\\n\\n            if (node.length == 2) {\\n                // Extension or Leaf node\\n\\n                bool isLeaf;\\n                bytes memory nodeKey;\\n                (isLeaf, nodeKey) = _merklePatriciaCompactDecode(node[0].toBytes());\\n\\n                uint256 prefixLength = _sharedPrefixLength(mptKeyOffset, mptKey, nodeKey);\\n                mptKeyOffset += prefixLength;\\n\\n                if (prefixLength < nodeKey.length) {\\n                    // Proof claims divergent extension or leaf. (Only\\n                    // relevant for proofs of exclusion.)\\n                    // An Extension/Leaf node is divergent iff it 'skips' over\\n                    // the point at which a Branch node should have been had the\\n                    // excluded key been included in the trie.\\n                    // Example: Imagine a proof of exclusion for path [1, 4],\\n                    // where the current node is a Leaf node with\\n                    // path [1, 3, 3, 7]. For [1, 4] to be included, there\\n                    // should have been a Branch node at [1] with a child\\n                    // at 3 and a child at 4.\\n\\n                    // Sanity check\\n                    if (i < stack.length - 1) {\\n                        // divergent node must come last in proof\\n                        revert();\\n                    }\\n\\n                    return new bytes(0);\\n                }\\n\\n                if (isLeaf) {\\n                    // Sanity check\\n                    if (i < stack.length - 1) {\\n                        // leaf node must come last in proof\\n                        revert();\\n                    }\\n\\n                    if (mptKeyOffset < mptKey.length) {\\n                        return new bytes(0);\\n                    }\\n\\n                    rlpValue = node[1];\\n                    return rlpValue.toBytes();\\n                } else {\\n                    // extension\\n                    // Sanity check\\n                    if (i == stack.length - 1) {\\n                        // shouldn't be at last level\\n                        revert();\\n                    }\\n\\n                    if (!node[1].isList()) {\\n                        // rlp(child) was at least 32 bytes. node[1] contains\\n                        // Keccak256(rlp(child)).\\n                        nodeHashHash = node[1].payloadKeccak256();\\n                    } else {\\n                        // rlp(child) was less than 32 bytes. node[1] contains\\n                        // rlp(child).\\n                        nodeHashHash = node[1].rlpBytesKeccak256();\\n                    }\\n                }\\n            } else if (node.length == 17) {\\n                // Branch node\\n\\n                if (mptKeyOffset != mptKey.length) {\\n                    // we haven't consumed the entire path, so we need to look at a child\\n                    uint8 nibble = uint8(mptKey[mptKeyOffset]);\\n                    mptKeyOffset += 1;\\n                    if (nibble >= 16) {\\n                        // each element of the path has to be a nibble\\n                        revert();\\n                    }\\n\\n                    if (_isEmptyBytesequence(node[nibble])) {\\n                        // Sanity\\n                        if (i != stack.length - 1) {\\n                            // leaf node should be at last level\\n                            revert();\\n                        }\\n\\n                        return new bytes(0);\\n                    } else if (!node[nibble].isList()) {\\n                        nodeHashHash = node[nibble].payloadKeccak256();\\n                    } else {\\n                        nodeHashHash = node[nibble].rlpBytesKeccak256();\\n                    }\\n                } else {\\n                    // we have consumed the entire mptKey, so we need to look at what's contained in this node.\\n\\n                    // Sanity\\n                    if (i != stack.length - 1) {\\n                        // should be at last level\\n                        revert();\\n                    }\\n\\n                    return node[16].toBytes();\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Computes the hash of the Merkle-Patricia-Trie hash of the RLP item.\\n    ///      Merkle-Patricia-Tries use a weird 'hash function' that outputs\\n    ///      *variable-length* hashes: If the item is shorter than 32 bytes,\\n    ///      the MPT hash is the item. Otherwise, the MPT hash is the\\n    ///      Keccak-256 hash of the item.\\n    ///      The easiest way to compare variable-length byte sequences is\\n    ///      to compare their Keccak-256 hashes.\\n    /// @param item The RLP item to be hashed.\\n    /// @return Keccak-256(MPT-hash(item))\\n    function _mptHashHash(RLPReader.RLPItem memory item) private pure returns (bytes32) {\\n        if (item.len < 32) {\\n            return item.rlpBytesKeccak256();\\n        } else {\\n            return keccak256(abi.encodePacked(item.rlpBytesKeccak256()));\\n        }\\n    }\\n\\n    function _isEmptyBytesequence(RLPReader.RLPItem memory item) private pure returns (bool) {\\n        if (item.len != 1) {\\n            return false;\\n        }\\n        uint8 b;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            b := byte(0, mload(memPtr))\\n        }\\n        return b == 0x80; /* empty byte string */\\n    }\\n\\n    function _merklePatriciaCompactDecode(\\n        bytes memory compact\\n    ) private pure returns (bool isLeaf, bytes memory nibbles) {\\n        require(compact.length > 0);\\n        uint256 first_nibble = (uint8(compact[0]) >> 4) & 0xF;\\n        uint256 skipNibbles;\\n        if (first_nibble == 0) {\\n            skipNibbles = 2;\\n            isLeaf = false;\\n        } else if (first_nibble == 1) {\\n            skipNibbles = 1;\\n            isLeaf = false;\\n        } else if (first_nibble == 2) {\\n            skipNibbles = 2;\\n            isLeaf = true;\\n        } else if (first_nibble == 3) {\\n            skipNibbles = 1;\\n            isLeaf = true;\\n        } else {\\n            // Not supposed to happen!\\n            revert();\\n        }\\n        return (isLeaf, _decodeNibbles(compact, skipNibbles));\\n    }\\n\\n    function _decodeNibbles(bytes memory compact, uint256 skipNibbles) private pure returns (bytes memory nibbles) {\\n        require(compact.length > 0);\\n\\n        uint256 length = compact.length * 2;\\n        require(skipNibbles <= length);\\n        length -= skipNibbles;\\n\\n        nibbles = new bytes(length);\\n        uint256 nibblesLength = 0;\\n\\n        for (uint256 i = skipNibbles; i < skipNibbles + length; i += 1) {\\n            if (i % 2 == 0) {\\n                nibbles[nibblesLength] = bytes1((uint8(compact[i / 2]) >> 4) & 0xF);\\n            } else {\\n                nibbles[nibblesLength] = bytes1((uint8(compact[i / 2]) >> 0) & 0xF);\\n            }\\n            nibblesLength += 1;\\n        }\\n\\n        assert(nibblesLength == nibbles.length);\\n    }\\n\\n    function _sharedPrefixLength(uint256 xsOffset, bytes memory xs, bytes memory ys) private pure returns (uint256) {\\n        uint256 i;\\n        for (i = 0; i + xsOffset < xs.length && i < ys.length; i++) {\\n            if (xs[i + xsOffset] != ys[i]) {\\n                return i;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n\",\"keccak256\":\"0x912d64a78914bbd046234ee4d5246b99f188c8bbd5e62f26125b6a6dda3ccdb5\"},\"contracts/Prover.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { RLPReader } from \\\"solidity-rlp/contracts/RLPReader.sol\\\";\\nimport { MerklePatriciaProofVerifier } from \\\".//MerklePatriciaProofVerifier.sol\\\";\\n\\ninterface IGiriGiriBashi {\\n\\tfunction getThresholdHash(\\n\\t\\tuint256 domain,\\n\\t\\tuint256 id\\n\\t) external view returns (bytes32);\\n}\\n\\nstruct Proof {\\n\\tuint256 blockNumber;\\n\\tuint256 nonce;\\n\\tbytes blockHeader;\\n\\tbytes32 storageRoot;\\n\\tbytes accountProof;\\n\\tbytes storageProof;\\n}\\n\\ninterface IProver {\\n\\terror InvalidLatestCommitment(\\n\\t\\tbytes32 latestCommitment,\\n\\t\\tbytes32 expectedLatestCommitment\\n\\t);\\n\\terror InvalidBlockHeader(\\n\\t\\tbytes32 blockHeaderHash,\\n\\t\\tbytes32 expectedBlockHeaderHash\\n\\t);\\n\\terror InvalidAccountStorageRoot();\\n\\terror InvalidNonce(uint256 nonce, uint256 expectedNonce);\\n\\terror InvalidAccountRlp(bytes accountRlp);\\n\\n\\tfunction setAccount(address account) external;\\n}\\n\\ncontract Prover is IProver {\\n\\tusing RLPReader for RLPReader.RLPItem;\\n\\tusing RLPReader for bytes;\\n\\n\\tuint256 public immutable SOURCE_CHAIN_ID;\\n\\tuint256 public immutable COMMITMENTS_SLOT;\\n\\taddress public ACCOUNT;\\n\\taddress public immutable GIRI_GIRI_BASHI;\\n\\n\\tuint256 public expectedNonce;\\n\\n\\tconstructor(\\n\\t\\tuint256 sourceChainId,\\n\\t\\tuint256 commitmentsSlot,\\n\\t\\taddress giriGiriBashi\\n\\t) {\\n\\t\\tSOURCE_CHAIN_ID = sourceChainId;\\n\\t\\tCOMMITMENTS_SLOT = commitmentsSlot;\\n\\t\\tGIRI_GIRI_BASHI = giriGiriBashi;\\n\\t}\\n\\n\\t// @inheritdoc IProver\\n\\tfunction setAccount(address account) external {\\n\\t\\tACCOUNT = account;\\n\\t}\\n\\n\\tfunction _verifyProof(\\n\\t\\tProof calldata proof,\\n\\t\\tbytes memory data\\n\\t) public returns (bool) {\\n\\t\\t// bytes32 expectedBlockHeaderHash = IGiriGiriBashi(GIRI_GIRI_BASHI)\\n\\t\\t// \\t.getThresholdHash(SOURCE_CHAIN_ID, proof.blockNumber);\\n\\t\\t// bytes32 blockHeaderHash = keccak256(proof.blockHeader);\\n\\t\\t// if (expectedBlockHeaderHash != blockHeaderHash)\\n\\t\\t// \\trevert InvalidBlockHeader(blockHeaderHash, expectedBlockHeaderHash);\\n\\n\\t\\tbytes32 expectedLatestCommitment = _verifyStorageProofAndGetValue(\\n\\t\\t\\t_verifyAccountProofAndGetStorageRoot(\\n\\t\\t\\t\\tproof.blockHeader,\\n\\t\\t\\t\\tproof.accountProof\\n\\t\\t\\t),\\n\\t\\t\\tproof.storageProof\\n\\t\\t);\\n\\t\\tbytes32 latestCommitment = keccak256(\\n\\t\\t\\tabi.encode(block.chainid, data, proof.nonce)\\n\\t\\t);\\n\\t\\tif (expectedLatestCommitment != latestCommitment) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// _checkNonceAndIncrementExpectedNonce(proof.nonce);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _verifyAccountProofAndGetStorageRoot(\\n\\t\\tbytes memory blockHeader,\\n\\t\\tbytes memory accountProof\\n\\t) internal view returns (bytes32) {\\n\\t\\tRLPReader.RLPItem[] memory blockHeaderFields = blockHeader\\n\\t\\t\\t.toRlpItem()\\n\\t\\t\\t.toList();\\n\\t\\tbytes32 stateRoot = bytes32(blockHeaderFields[3].toUint());\\n\\t\\tbytes memory accountRlp = MerklePatriciaProofVerifier.extractProofValue(\\n\\t\\t\\tstateRoot,\\n\\t\\t\\tabi.encodePacked(keccak256(abi.encodePacked(ACCOUNT))),\\n\\t\\t\\taccountProof.toRlpItem().toList()\\n\\t\\t);\\n\\t\\tbytes32 accountStorageRoot = bytes32(\\n\\t\\t\\taccountRlp.toRlpItem().toList()[2].toUint()\\n\\t\\t);\\n\\t\\tif (accountStorageRoot.length == 0) revert InvalidAccountStorageRoot();\\n\\t\\tRLPReader.RLPItem[] memory accountFields = accountRlp\\n\\t\\t\\t.toRlpItem()\\n\\t\\t\\t.toList();\\n\\t\\tif (accountFields.length != 4) revert InvalidAccountRlp(accountRlp); // [nonce, balance, storageRoot, codeHash]\\n\\t\\treturn bytes32(accountFields[2].toUint());\\n\\t}\\n\\n\\tfunction _verifyStorageProofAndGetValue(\\n\\t\\tbytes32 storageRoot,\\n\\t\\tbytes calldata storageProof\\n\\t) internal view returns (bytes32) {\\n\\t\\tbytes memory slotValue = MerklePatriciaProofVerifier.extractProofValue(\\n\\t\\t\\tstorageRoot,\\n\\t\\t\\t// abi.encodePacked(\\n\\t\\t\\t// \\tkeccak256(\\n\\t\\t\\t// \\t\\tabi.encode(\\n\\t\\t\\t// \\t\\t\\tkeccak256(abi.encode(msg.sender, COMMITMENTS_SLOT))\\n\\t\\t\\t// \\t\\t)\\n\\t\\t\\t// \\t)\\n\\t\\t\\t// ),\\n\\t\\t\\tabi.encodePacked(keccak256(abi.encodePacked(uint256(0)))),\\n\\t\\t\\tstorageProof.toRlpItem().toList()\\n\\t\\t);\\n\\t\\treturn _bytesToBytes32(slotValue);\\n\\t}\\n\\n\\tfunction _checkNonceAndIncrementExpectedNonce(uint256 nonce) internal {\\n\\t\\tif (nonce != expectedNonce) revert InvalidNonce(nonce, expectedNonce);\\n\\t\\tunchecked {\\n\\t\\t\\t++expectedNonce;\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _bytesToBytes32(\\n\\t\\tbytes memory source\\n\\t) internal pure returns (bytes32 result) {\\n\\t\\tif (source.length == 0) {\\n\\t\\t\\treturn bytes32(0);\\n\\t\\t}\\n\\t\\t// solhint-disable-next-line\\n\\t\\tassembly {\\n\\t\\t\\tresult := mload(add(add(source, 1), 32))\\n\\t\\t}\\n\\t}\\n}\\n\",\"keccak256\":\"0x1166b8aa5caccf3770f22df4edc0b5a301aecacf2513c9c71436eef18150e7fc\",\"license\":\"MIT\"},\"solidity-rlp/contracts/RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity >=0.5.10 <0.9.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that's being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr < item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An 'Iterator' over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     * @return (memPtr, len) pair: location of the item's payload in memory.\\n     */\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @param the RLP item.\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        (, uint256 len) = payloadLocation(item);\\n        return len;\\n    }\\n\\n    /*\\n     * @param the RLP item containing the encoded list.\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i < items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte except \\\"0x80\\\" is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        // SEE Github Issue #5.\\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\\n        // \\\"0\\\" as \\\"0x80\\\" instead of as \\\"0\\\". We handle this edge case explicitly\\n        // here.\\n        if (result == 0 || result == STRING_SHORT_START) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len > 0 && item.len <= 33);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\n        uint256 result;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shift to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len > 0);\\n\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(memPtr, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr < endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            itemLen = 1;\\n        } else if (byte0 < STRING_LONG_START) {\\n            itemLen = byte0 - STRING_SHORT_START + 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 < LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 < STRING_SHORT_START) {\\n            return 0;\\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\\n            return 1;\\n        } else if (byte0 < LIST_SHORT_START) {\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        } else {\\n            return byte0 - (LIST_LONG_START - 1) + 1;\\n        }\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len > 0) {\\n            // left over bytes. Mask is used to remove unwanted bytes from the word\\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask)) // zero out src\\n                let destpart := and(mload(dest), mask) // retrieve the bytes\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3a44f2de3c752fa4f926f3fd4cad8338dab742484150c0d7d2f785409ed8db4d\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60e03461009057601f61122438819003918201601f19168301916001600160401b0383118484101761009557808492606094604052833981010312610090578051602082015160409092015191906001600160a01b03831683036100905760805260a05260c05260405161117890816100ac823960805181610284015260a05181610249015260c051816102d40152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe6080604052600436101561001257600080fd5b6000803560e01c90816307b244581461008a5750806329f6d57c1461008557806332b55cbf1461008057806374be21501461007b578063cb7cf18114610076578063e90524f2146100715763ebe445fc1461006c57600080fd5b61032c565b6102f8565b6102a7565b61026c565b610231565b6101d1565b3461010a5760031960403682011261010d576004359167ffffffffffffffff9182841161010d5760c090843603011261010a5760243591821161010a573660238301121561010a576101066100f4846100eb36600487013560248801610195565b906004016103df565b60405190151581529081906020820190565b0390f35b80fd5b5080fd5b634e487b7160e01b600052604160045260246000fd5b6040810190811067ffffffffffffffff82111761014357604052565b610111565b90601f8019910116810190811067ffffffffffffffff82111761014357604052565b6040519061017782610127565b565b67ffffffffffffffff811161014357601f01601f191660200190565b9291926101a182610179565b916101af6040519384610148565b8294818452818301116101cc578281602093846000960137010152565b600080fd5b346101cc5760203660031901126101cc5760043573ffffffffffffffffffffffffffffffffffffffff81168091036101cc577fffffffffffffffffffffffff00000000000000000000000000000000000000006000541617600055600080f35b346101cc5760003660031901126101cc5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101cc5760003660031901126101cc5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101cc5760003660031901126101cc57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346101cc5760003660031901126101cc57602073ffffffffffffffffffffffffffffffffffffffff60005416604051908152f35b346101cc5760003660031901126101cc576020600154604051908152f35b903590601e19813603018212156101cc570180359067ffffffffffffffff82116101cc576020019181360383136101cc57565b919082519283825260005b8481106103a9575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201610388565b9392916103da90604092865260606020870152606086019061037d565b930152565b6104236104d061043961043361042e6104296103fe604088018861034a565b61041b61041160808b9a949a018b61034a565b9990923691610195565b973691610195565b95610d9b565b610dd9565b6105ad565b51610f02565b6104b96104ca61042961046160005473ffffffffffffffffffffffffffffffffffffffff1690565b956104c5604051978861048f6020820192836014916bffffffffffffffffffffffff199060601b1681520190565b03986104a3601f199a8b8101835282610148565b5190206040519586916020830160209181520190565b03888101865285610148565b610d9b565b9161075f565b6104e76104336104e261042984610d9b565b6105c2565b506104f461042982610d9b565b90600482510361055d575061053f9161052861051561043361054b946105c2565b61052260a087018761034a565b91610d42565b9460405193849160208084019701359046886103bd565b03908101835282610148565b5190200361055857600190565b600090565b610593906040519182917fffdec2a500000000000000000000000000000000000000000000000000000000835260048301610614565b0390fd5b634e487b7160e01b600052603260045260246000fd5b8051600310156105bd5760800190565b610597565b8051600210156105bd5760600190565b8051601010156105bd576102200190565b8051156105bd5760200190565b8051600110156105bd5760400190565b80518210156105bd5760209160051b010190565b90602061062592818152019061037d565b90565b6040519061063582610127565b60006020838281520152565b156101cc57565b6040516020810181811067ffffffffffffffff8211176101435760405260008152906000368137565b9061067b82610179565b6106886040519182610148565b8281528092610699601f1991610179565b0190602036910137565b634e487b7160e01b600052601160045260246000fd5b60001981146106c85760010190565b6106a3565b6000198101919082116106c857565b60bf198101919082116106c857565b607f198101919082116106c857565b60200390602082116106c857565b60f6198101919082116106c857565b60b6198101919082116106c857565b919082039182116106c857565b9081518110156105bd570160200190565b90600182018092116106c857565b919082018092116106c857565b9061076b606091610c1e565b906000928390610779610628565b50855115610a1e57916000959195925b8251841015610a1457831580806109fe575b6101cc5715806109e2575b6101cc576107bd6107b78585610600565b51610dd9565b968751600281146000146108c55750506107e76107e26107dc896105e3565b51610f44565b610ab0565b966107fd6107f6898984610cbb565b8092610752565b9751116108a6571561083557505061081590516106cd565b116101cc57511161082c576107dc610625916105f0565b50610625610648565b9092919561084387516106cd565b83146101cc578061086661086261085c610883946105f0565b51610eac565b1590565b1561088d5761087761087d916105f0565b51610ec8565b926106b9565b9290959195610789565b61089961087d916105f0565b5160208101519051902090565b505050915092506108b89150516106cd565b116101cc57610625610648565b6011909891949895929395146108e0575b50610883906106b9565b8551919796959493509085146109c05760ff61093761093161092b6109058989610733565b517fff000000000000000000000000000000000000000000000000000000000000001690565b60f81c90565b96610744565b95169060108210156101cc576109566109508383610600565b51610a93565b156109785750505050505061096b90516106cd565b036101cc57610625610648565b908161099361086261085c84610883969c98999a9b9c610600565b156109ad576109a59161087791610600565b925b906108d6565b6109ba9161089991610600565b926109a7565b9594925050506109d19150516106cd565b036101cc576107dc610625916105d2565b506109f66109f08585610600565b51610a58565b8714156107a6565b50610a0c6108998686610600565b82141561079b565b5095945050505050565b92505050610a5092507f56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421915014610641565b610625610648565b80516020811015610a70575060208101519051902090565b9060200151206040516020810191825260208152610a8d81610127565b51902090565b6001815103610aaa57602001515160001a60801490565b50600090565b908151156101cc57610ac1826105e3565b5160009060fc1c80610baf5750506002906000925b610b0083610aef8351610aea811515610641565b610beb565b610afb81831115610641565b610726565b91610b0a83610671565b94849360005b610b1a8288610752565b861015610b985790610b74610931610b1a93600f60f81b89600180821615600014610b7d5761092b610905610b5d93610b54931c8d610733565b60041c600f1690565b60f81b1660001a610b6e828d610733565b53610744565b95909150610b10565b61092b610905610b5d93610b92931c8d610733565b60ff1690565b929550509250610bab9150845114610c01565b9190565b60018103610bc4575050600190600092610ad6565b60028103610bd9575050600290600192610ad6565b60030361010a57506001908192610ad6565b908160011b91808304600214901517156106c857565b15610c0857565b634e487b7160e01b600052600160045260246000fd5b90610c2f8251610aea811515610641565b91610c3983610671565b9260009081925b818410610c565750506101779150835114610c01565b9091610c98610c9e91600f60f81b86600180821615600014610ca65761092b610905610c8793610b54931c89610733565b60f81b1660001a610b6e828a610733565b93610744565b929190610c40565b61092b610905610c8793610b92931c89610733565b919060005b8381018082116106c8578251811080610d38575b15610d3057610d07907fff0000000000000000000000000000000000000000000000000000000000000091829185610733565b511690610d148386610733565b511603610d2957610d24906106b9565b610cc0565b9250505090565b509250505090565b5083518210610cd4565b610625926104ca6104296104c5610d8d9560405160208101906000825260208152610d6c81610127565b5190209460405195602087015260208652610d8686610127565b3691610195565b805115610aaa576021015190565b610da3610628565b50602081519160405192610db684610127565b835201602082015290565b67ffffffffffffffff81116101435760051b60200190565b610de281610eac565b156101cc57610df081610f6e565b610df981610dc1565b91610e076040519384610148565b818352601f19610e1683610dc1565b0160005b818110610e95575050610e3b602080920151610e3581611056565b90610752565b6000905b838210610e4d575050505090565b610e8981610e5d610e8f93610fd0565b90610e6661016a565b8281528187820152610e78868a610600565b52610e838589610600565b50610752565b916106b9565b90610e3f565b602090610ea0610628565b82828801015201610e1a565b805115610aaa57602060c09101515160001a1061055857600190565b610ed190610ed6565b902090565b906020820191610ee68351611056565b9251908382018092116106c857519283039283116106c8579190565b80518015159081610f38575b50156101cc57610f1d90610ed6565b90519060208110610f2c575090565b6020036101000a900490565b60219150111538610f0e565b8051156101cc57610f5761062591610ed6565b610f6381939293610671565b9283602001906110c5565b805115610aaa5760009060208101908151610f8881611056565b81018091116106c8579151905181018091116106c85791905b828110610fae5750905090565b610fb781610fd0565b81018091116106c857610fca90916106b9565b90610fa1565b805160001a906080821015610fe6575050600190565b60b88210156110015750610ffc610625916106eb565b610744565b9060c08110156110255760b51991600160b783602003016101000a91015104010190565b9060f882101561103c5750610ffc610625916106dc565b60010151602082900360f7016101000a90040160f5190190565b5160001a60808110156110695750600090565b60b8811080156110a0575b1561107f5750600190565b60c081101561109457610ffc61062591610717565b610ffc61062591610708565b5060c08110158015611074575060f88110611074565b601f81116106c8576101000a90565b92909192831561113c5792915b60209384841061110757805182528481018091116106c8579381018091116106c85791601f1981019081116106c857916110d2565b919350918061111557505050565b61112961112461112e926106fa565b6110b6565b6106cd565b905182518216911916179052565b5091505056fea264697066735822122017932524ef2fadebde2f3158acf5862936f2bc55c8ae93cf983550cb1ad9189f64736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436101561001257600080fd5b6000803560e01c90816307b244581461008a5750806329f6d57c1461008557806332b55cbf1461008057806374be21501461007b578063cb7cf18114610076578063e90524f2146100715763ebe445fc1461006c57600080fd5b61032c565b6102f8565b6102a7565b61026c565b610231565b6101d1565b3461010a5760031960403682011261010d576004359167ffffffffffffffff9182841161010d5760c090843603011261010a5760243591821161010a573660238301121561010a576101066100f4846100eb36600487013560248801610195565b906004016103df565b60405190151581529081906020820190565b0390f35b80fd5b5080fd5b634e487b7160e01b600052604160045260246000fd5b6040810190811067ffffffffffffffff82111761014357604052565b610111565b90601f8019910116810190811067ffffffffffffffff82111761014357604052565b6040519061017782610127565b565b67ffffffffffffffff811161014357601f01601f191660200190565b9291926101a182610179565b916101af6040519384610148565b8294818452818301116101cc578281602093846000960137010152565b600080fd5b346101cc5760203660031901126101cc5760043573ffffffffffffffffffffffffffffffffffffffff81168091036101cc577fffffffffffffffffffffffff00000000000000000000000000000000000000006000541617600055600080f35b346101cc5760003660031901126101cc5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101cc5760003660031901126101cc5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346101cc5760003660031901126101cc57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346101cc5760003660031901126101cc57602073ffffffffffffffffffffffffffffffffffffffff60005416604051908152f35b346101cc5760003660031901126101cc576020600154604051908152f35b903590601e19813603018212156101cc570180359067ffffffffffffffff82116101cc576020019181360383136101cc57565b919082519283825260005b8481106103a9575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201610388565b9392916103da90604092865260606020870152606086019061037d565b930152565b6104236104d061043961043361042e6104296103fe604088018861034a565b61041b61041160808b9a949a018b61034a565b9990923691610195565b973691610195565b95610d9b565b610dd9565b6105ad565b51610f02565b6104b96104ca61042961046160005473ffffffffffffffffffffffffffffffffffffffff1690565b956104c5604051978861048f6020820192836014916bffffffffffffffffffffffff199060601b1681520190565b03986104a3601f199a8b8101835282610148565b5190206040519586916020830160209181520190565b03888101865285610148565b610d9b565b9161075f565b6104e76104336104e261042984610d9b565b6105c2565b506104f461042982610d9b565b90600482510361055d575061053f9161052861051561043361054b946105c2565b61052260a087018761034a565b91610d42565b9460405193849160208084019701359046886103bd565b03908101835282610148565b5190200361055857600190565b600090565b610593906040519182917fffdec2a500000000000000000000000000000000000000000000000000000000835260048301610614565b0390fd5b634e487b7160e01b600052603260045260246000fd5b8051600310156105bd5760800190565b610597565b8051600210156105bd5760600190565b8051601010156105bd576102200190565b8051156105bd5760200190565b8051600110156105bd5760400190565b80518210156105bd5760209160051b010190565b90602061062592818152019061037d565b90565b6040519061063582610127565b60006020838281520152565b156101cc57565b6040516020810181811067ffffffffffffffff8211176101435760405260008152906000368137565b9061067b82610179565b6106886040519182610148565b8281528092610699601f1991610179565b0190602036910137565b634e487b7160e01b600052601160045260246000fd5b60001981146106c85760010190565b6106a3565b6000198101919082116106c857565b60bf198101919082116106c857565b607f198101919082116106c857565b60200390602082116106c857565b60f6198101919082116106c857565b60b6198101919082116106c857565b919082039182116106c857565b9081518110156105bd570160200190565b90600182018092116106c857565b919082018092116106c857565b9061076b606091610c1e565b906000928390610779610628565b50855115610a1e57916000959195925b8251841015610a1457831580806109fe575b6101cc5715806109e2575b6101cc576107bd6107b78585610600565b51610dd9565b968751600281146000146108c55750506107e76107e26107dc896105e3565b51610f44565b610ab0565b966107fd6107f6898984610cbb565b8092610752565b9751116108a6571561083557505061081590516106cd565b116101cc57511161082c576107dc610625916105f0565b50610625610648565b9092919561084387516106cd565b83146101cc578061086661086261085c610883946105f0565b51610eac565b1590565b1561088d5761087761087d916105f0565b51610ec8565b926106b9565b9290959195610789565b61089961087d916105f0565b5160208101519051902090565b505050915092506108b89150516106cd565b116101cc57610625610648565b6011909891949895929395146108e0575b50610883906106b9565b8551919796959493509085146109c05760ff61093761093161092b6109058989610733565b517fff000000000000000000000000000000000000000000000000000000000000001690565b60f81c90565b96610744565b95169060108210156101cc576109566109508383610600565b51610a93565b156109785750505050505061096b90516106cd565b036101cc57610625610648565b908161099361086261085c84610883969c98999a9b9c610600565b156109ad576109a59161087791610600565b925b906108d6565b6109ba9161089991610600565b926109a7565b9594925050506109d19150516106cd565b036101cc576107dc610625916105d2565b506109f66109f08585610600565b51610a58565b8714156107a6565b50610a0c6108998686610600565b82141561079b565b5095945050505050565b92505050610a5092507f56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421915014610641565b610625610648565b80516020811015610a70575060208101519051902090565b9060200151206040516020810191825260208152610a8d81610127565b51902090565b6001815103610aaa57602001515160001a60801490565b50600090565b908151156101cc57610ac1826105e3565b5160009060fc1c80610baf5750506002906000925b610b0083610aef8351610aea811515610641565b610beb565b610afb81831115610641565b610726565b91610b0a83610671565b94849360005b610b1a8288610752565b861015610b985790610b74610931610b1a93600f60f81b89600180821615600014610b7d5761092b610905610b5d93610b54931c8d610733565b60041c600f1690565b60f81b1660001a610b6e828d610733565b53610744565b95909150610b10565b61092b610905610b5d93610b92931c8d610733565b60ff1690565b929550509250610bab9150845114610c01565b9190565b60018103610bc4575050600190600092610ad6565b60028103610bd9575050600290600192610ad6565b60030361010a57506001908192610ad6565b908160011b91808304600214901517156106c857565b15610c0857565b634e487b7160e01b600052600160045260246000fd5b90610c2f8251610aea811515610641565b91610c3983610671565b9260009081925b818410610c565750506101779150835114610c01565b9091610c98610c9e91600f60f81b86600180821615600014610ca65761092b610905610c8793610b54931c89610733565b60f81b1660001a610b6e828a610733565b93610744565b929190610c40565b61092b610905610c8793610b92931c89610733565b919060005b8381018082116106c8578251811080610d38575b15610d3057610d07907fff0000000000000000000000000000000000000000000000000000000000000091829185610733565b511690610d148386610733565b511603610d2957610d24906106b9565b610cc0565b9250505090565b509250505090565b5083518210610cd4565b610625926104ca6104296104c5610d8d9560405160208101906000825260208152610d6c81610127565b5190209460405195602087015260208652610d8686610127565b3691610195565b805115610aaa576021015190565b610da3610628565b50602081519160405192610db684610127565b835201602082015290565b67ffffffffffffffff81116101435760051b60200190565b610de281610eac565b156101cc57610df081610f6e565b610df981610dc1565b91610e076040519384610148565b818352601f19610e1683610dc1565b0160005b818110610e95575050610e3b602080920151610e3581611056565b90610752565b6000905b838210610e4d575050505090565b610e8981610e5d610e8f93610fd0565b90610e6661016a565b8281528187820152610e78868a610600565b52610e838589610600565b50610752565b916106b9565b90610e3f565b602090610ea0610628565b82828801015201610e1a565b805115610aaa57602060c09101515160001a1061055857600190565b610ed190610ed6565b902090565b906020820191610ee68351611056565b9251908382018092116106c857519283039283116106c8579190565b80518015159081610f38575b50156101cc57610f1d90610ed6565b90519060208110610f2c575090565b6020036101000a900490565b60219150111538610f0e565b8051156101cc57610f5761062591610ed6565b610f6381939293610671565b9283602001906110c5565b805115610aaa5760009060208101908151610f8881611056565b81018091116106c8579151905181018091116106c85791905b828110610fae5750905090565b610fb781610fd0565b81018091116106c857610fca90916106b9565b90610fa1565b805160001a906080821015610fe6575050600190565b60b88210156110015750610ffc610625916106eb565b610744565b9060c08110156110255760b51991600160b783602003016101000a91015104010190565b9060f882101561103c5750610ffc610625916106dc565b60010151602082900360f7016101000a90040160f5190190565b5160001a60808110156110695750600090565b60b8811080156110a0575b1561107f5750600190565b60c081101561109457610ffc61062591610717565b610ffc61062591610708565b5060c08110158015611074575060f88110611074565b601f81116106c8576101000a90565b92909192831561113c5792915b60209384841061110757805182528481018091116106c8579381018091116106c85791601f1981019081116106c857916110d2565b919350918061111557505050565b61112961112461112e926106fa565b6110b6565b6106cd565b905182518216911916179052565b5091505056fea264697066735822122017932524ef2fadebde2f3158acf5862936f2bc55c8ae93cf983550cb1ad9189f64736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3961,
        "contract": "contracts/Prover.sol:Prover",
        "label": "ACCOUNT",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 3965,
        "contract": "contracts/Prover.sol:Prover",
        "label": "expectedNonce",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}